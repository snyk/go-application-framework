// Package v20241015 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v20241015

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ConfigAttributesScope.
const (
	ConfigAttributesScopeAsset       ConfigAttributesScope = "asset"
	ConfigAttributesScopeGlobal      ConfigAttributesScope = "global"
	ConfigAttributesScopeGroup       ConfigAttributesScope = "group"
	ConfigAttributesScopeOrg         ConfigAttributesScope = "org"
	ConfigAttributesScopeProjectName ConfigAttributesScope = "project_name"
	ConfigAttributesScopeRemoteUrl   ConfigAttributesScope = "remote_url"
	ConfigAttributesScopeTenant      ConfigAttributesScope = "tenant"
	ConfigAttributesScopeUser        ConfigAttributesScope = "user"
)

// Defines values for ConfigDataAuthenticationMethod.
const (
	Oauth ConfigDataAuthenticationMethod = "oauth"
	Pat   ConfigDataAuthenticationMethod = "pat"
	Token ConfigDataAuthenticationMethod = "token"
)

// Defines values for ConfigResourceType.
const (
	ConfigResourceTypeConfig ConfigResourceType = "config"
)

// Defines values for ConfigResponseJsonapiVersion.
const (
	ConfigResponseJsonapiVersionN10 ConfigResponseJsonapiVersion = "1.0"
)

// Defines values for ConfigurationRequestDataType.
const (
	ConfigurationRequestDataTypeConfig ConfigurationRequestDataType = "config"
)

// Defines values for ErrorDocument0JsonapiVersion.
const (
	ErrorDocument0JsonapiVersionN10 ErrorDocument0JsonapiVersion = "1.0"
)

// Defines values for SettingMetadataOrigin.
const (
	SettingMetadataOriginGlobal SettingMetadataOrigin = "global"
	SettingMetadataOriginGroup  SettingMetadataOrigin = "group"
	SettingMetadataOriginOrg    SettingMetadataOrigin = "org"
	SettingMetadataOriginTenant SettingMetadataOrigin = "tenant"
	SettingMetadataOriginUser   SettingMetadataOrigin = "user"
)

// Defines values for UserConfigResponseDataAttributesScope.
const (
	Global UserConfigResponseDataAttributesScope = "global"
	Group  UserConfigResponseDataAttributesScope = "group"
	Org    UserConfigResponseDataAttributesScope = "org"
	Tenant UserConfigResponseDataAttributesScope = "tenant"
	User   UserConfigResponseDataAttributesScope = "user"
)

// Defines values for UserConfigResponseDataType.
const (
	Configuration UserConfigResponseDataType = "configuration"
)

// Defines values for UserConfigResponseJsonapiVersion.
const (
	N10 UserConfigResponseJsonapiVersion = "1.0"
)

// ActualVersion Resolved API version
type ActualVersion = string

// AttributeSource Configuration location sources
type AttributeSource struct {
	// Asset Asset-level configuration sources
	Asset *[]string `json:"asset,omitempty"`

	// Group Group-level configuration sources
	Group *[]string `json:"group,omitempty"`

	// Org Organization-level configuration sources
	Org *[]string `json:"org,omitempty"`

	// ProjectName Project name configuration sources (used when asset is not set)
	ProjectName *[]string `json:"project_name,omitempty"`

	// RemoteUrl repo-level configuration sources
	RemoteUrl *[]string `json:"remote_url,omitempty"`

	// Tenant Tenant-level configuration sources
	Tenant *[]string `json:"tenant,omitempty"`
}

// BinaryManagementConfig defines model for BinaryManagementConfig.
type BinaryManagementConfig struct {
	// AutomaticDownload Whether to automatically download CLI updates
	AutomaticDownload *bool `json:"automatic_download,omitempty"`

	// CliPath Path to the Snyk CLI binary
	CliPath *string `json:"cli_path,omitempty"`
}

// CodeAction defines model for CodeAction.
type CodeAction struct {
	// Enabled Whether the code action is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

// ConfigAttributes defines model for ConfigAttributes.
type ConfigAttributes struct {
	// AttributeSource Configuration location sources
	AttributeSource AttributeSource `json:"attribute_source"`
	ConfigData      ConfigData      `json:"config_data"`

	// CreatedAt Timestamp when the configuration was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// LastModifiedAt Timestamp of the last configuration update
	LastModifiedAt time.Time `json:"last_modified_at"`
	Policy         *Policy   `json:"policy,omitempty"`

	// Scope The highest scope level of the returned configuration
	Scope ConfigAttributesScope `json:"scope"`
}

// ConfigAttributesScope The highest scope level of the returned configuration
type ConfigAttributesScope string

// ConfigData defines model for ConfigData.
type ConfigData struct {
	// AuthenticationMethod Authentication method to use
	AuthenticationMethod *ConfigDataAuthenticationMethod `json:"authentication_method,omitempty"`
	Endpoints            *Endpoints                      `json:"endpoints,omitempty"`
	FilterConfig         *FilterConfig                   `json:"filter_config,omitempty"`
	FolderConfigs        *FolderConfigs                  `json:"folder_configs,omitempty"`

	// IdeConfigs Map of IDE configurations keyed by integration_name
	IdeConfigs *IdeConfigs `json:"ide_configs,omitempty"`

	// Organizations This list includes all organizations the user has access to.
	Organizations *[]Organization `json:"organizations,omitempty"`
	ProxyConfig   *ProxyConfig    `json:"proxy_config,omitempty"`
}

// ConfigDataAuthenticationMethod Authentication method to use
type ConfigDataAuthenticationMethod string

// ConfigResource defines model for ConfigResource.
type ConfigResource struct {
	Attributes ConfigAttributes `json:"attributes"`

	// Id Unique identifier for this configuration instance
	Id openapi_types.UUID `json:"id"`

	// Type Resource type
	Type ConfigResourceType `json:"type"`
}

// ConfigResourceType Resource type
type ConfigResourceType string

// ConfigResponse defines model for ConfigResponse.
type ConfigResponse struct {
	Data    ConfigResource `json:"data"`
	Jsonapi *struct {
		Version *ConfigResponseJsonapiVersion `json:"version,omitempty"`
	} `json:"jsonapi,omitempty"`
	Links *struct {
		// Self Link to this resource
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`
	Meta *ResponseMeta `json:"meta,omitempty"`
}

// ConfigResponseJsonapiVersion defines model for ConfigResponse.Jsonapi.Version.
type ConfigResponseJsonapiVersion string

// ConfigurationRequest Configuration request object for creating or updating configurations.
// For PATCH operations, only provided fields will be updated.
type ConfigurationRequest struct {
	Data struct {
		Attributes struct {
			ConfigData *ConfigData `json:"config_data,omitempty"`
			Policy     *Policy     `json:"policy,omitempty"`
		} `json:"attributes"`

		// Type Resource type
		Type ConfigurationRequestDataType `json:"type"`
	} `json:"data"`
}

// ConfigurationRequestDataType Resource type
type ConfigurationRequestDataType string

// Endpoints defines model for Endpoints.
type Endpoints struct {
	// ApiEndpoint Snyk API endpoint
	ApiEndpoint *string `json:"api_endpoint,omitempty"`

	// CodeEndpoint Snyk Code API endpoint
	CodeEndpoint *string `json:"code_endpoint,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Code An application-specific error code, expressed as a string value.
	Code *string `json:"code,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Id A unique identifier for this particular occurrence of the problem.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Links A link that leads to further details about this particular occurrance of the problem.
	Links  *ErrorLink              `json:"links,omitempty"`
	Meta   *map[string]interface{} `json:"meta,omitempty"`
	Source *struct {
		// Parameter A string indicating which URI query parameter caused the error.
		Parameter *string `json:"parameter,omitempty"`

		// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
		Pointer *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `json:"title,omitempty"`
}

// ErrorDocument defines model for ErrorDocument.
type ErrorDocument struct {
	Errors  []Error `json:"errors"`
	Jsonapi JsonApi `json:"jsonapi"`
}

// ErrorDocument0 defines model for ErrorDocument__0.
type ErrorDocument0 struct {
	Errors  []Error0 `json:"errors"`
	Jsonapi *struct {
		Version *ErrorDocument0JsonapiVersion `json:"version,omitempty"`
	} `json:"jsonapi,omitempty"`
}

// ErrorDocument0JsonapiVersion defines model for ErrorDocument0.Jsonapi.Version.
type ErrorDocument0JsonapiVersion string

// ErrorLink A link that leads to further details about this particular occurrance of the problem.
type ErrorLink struct {
	About *LinkProperty `json:"about,omitempty"`
}

// Error0 defines model for Error__0.
type Error0 struct {
	// Code An application-specific error code
	Code *string `json:"code,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem
	Detail string `json:"detail"`

	// Id A unique identifier for this particular occurrence of the problem
	Id    *openapi_types.UUID `json:"id,omitempty"`
	Links *struct {
		// About A link that leads to further details about this particular occurrence of the problem
		About *string `json:"about,omitempty"`
	} `json:"links,omitempty"`

	// Meta Additional error metadata
	Meta   *map[string]interface{} `json:"meta,omitempty"`
	Source *struct {
		// Parameter A string indicating which query parameter caused the error
		Parameter *string `json:"parameter,omitempty"`

		// Pointer A JSON Pointer to the value in the request that caused the error
		Pointer *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem
	Title *string `json:"title,omitempty"`
}

// FilterConfig defines model for FilterConfig.
type FilterConfig struct {
	// Cve CVE IDs to filter
	Cve *[]string `json:"cve,omitempty"`

	// Cwe CWE IDs to filter
	Cwe *[]string `json:"cwe,omitempty"`

	// RiskScoreThreshold Minimum risk score to display
	RiskScoreThreshold *int `json:"risk_score_threshold,omitempty"`

	// Rule Rule IDs to filter
	Rule       *[]string `json:"rule,omitempty"`
	Severities *struct {
		Critical *bool `json:"critical,omitempty"`
		High     *bool `json:"high,omitempty"`
		Low      *bool `json:"low,omitempty"`
		Medium   *bool `json:"medium,omitempty"`
	} `json:"severities,omitempty"`
}

// FolderConfig defines model for FolderConfig.
type FolderConfig struct {
	// AdditionalEnvironment Additional environment variables
	AdditionalEnvironment *[]string `json:"additional_environment,omitempty"`

	// AdditionalParameters Additional CLI parameters
	AdditionalParameters *[]string `json:"additional_parameters,omitempty"`

	// FolderPath Folder path relative to remote_url
	FolderPath string `json:"folder_path"`

	// Organizations This list includes only organizations
	// that have access to the specified repository, sorted by relevance.
	// The preferred organization is marked with preferred_by_algorithm: true.
	Organizations *[]Organization `json:"organizations,omitempty"`

	// PostScanExecuteCommand Command to execute after scanning
	PostScanExecuteCommand *string `json:"post_scan_execute_command,omitempty"`

	// PreScanExecuteCommand Command to execute before scanning
	PreScanExecuteCommand *string `json:"pre_scan_execute_command,omitempty"`

	// ReferenceBranch Git reference branch
	ReferenceBranch *string `json:"reference_branch,omitempty"`

	// ReferenceFolder Reference folder path relative to remote_url
	ReferenceFolder *string `json:"reference_folder,omitempty"`

	// RemoteUrl Repository URL
	// Supports various Git URL formats including HTTPS and SSH.
	RemoteUrl string `json:"remote_url"`
}

// FolderConfigs defines model for FolderConfigs.
type FolderConfigs = []FolderConfig

// IdeConfig defines model for IdeConfig.
type IdeConfig struct {
	// AutoConfigureMcpServer Configure Snyk MCP server
	AutoConfigureMcpServer *bool                   `json:"auto_configure_mcp_server,omitempty"`
	BinaryManagementConfig *BinaryManagementConfig `json:"binary_management_config,omitempty"`
	CodeActions            *struct {
		OpenBrowser     *CodeAction `json:"open_browser,omitempty"`
		OpenLearnLesson *CodeAction `json:"open_learn_lesson,omitempty"`
		ScaUpgrade      *CodeAction `json:"sca_upgrade,omitempty"`
	} `json:"code_actions,omitempty"`

	// HoverVerbosity Verbosity level for hover information
	HoverVerbosity *int `json:"hover_verbosity,omitempty"`

	// IntegrationName Name of the IDE integration
	IntegrationName *string          `json:"integration_name,omitempty"`
	IssueViewConfig *IssueViewConfig `json:"issue_view_config,omitempty"`

	// PersistRulesInProjects Write Snyk rules to current project. False will write it globally to user profile.
	PersistRulesInProjects *bool          `json:"persist_rules_in_projects,omitempty"`
	ProductConfig          *ProductConfig `json:"product_config,omitempty"`

	// PublishSecurityAtInceptionRules Publish Security at Inception rules
	PublishSecurityAtInceptionRules *bool        `json:"publish_security_at_inception_rules,omitempty"`
	ScanConfig                      *ScanConfig  `json:"scan_config,omitempty"`
	TrustConfig                     *TrustConfig `json:"trust_config,omitempty"`
}

// IdeConfigs Map of IDE configurations keyed by integration_name
type IdeConfigs map[string]IdeConfig

// IssueViewConfig defines model for IssueViewConfig.
type IssueViewConfig struct {
	// IgnoredIssues Show ignored issues
	IgnoredIssues *bool `json:"ignored_issues,omitempty"`

	// OpenIssues Show open issues
	OpenIssues *bool `json:"open_issues,omitempty"`
}

// JsonApi defines model for JsonApi.
type JsonApi struct {
	// Version Version of the JSON API specification this server supports.
	Version string `json:"version"`
}

// LinkProperty defines model for LinkProperty.
type LinkProperty struct {
	union json.RawMessage
}

// LinkProperty0 A string containing the link’s URL.
type LinkProperty0 = string

// LinkProperty1 defines model for .
type LinkProperty1 struct {
	// Href A string containing the link’s URL.
	Href string `json:"href"`

	// Meta Free-form object that may contain non-standard information.
	Meta *Meta `json:"meta,omitempty"`
}

// Meta Free-form object that may contain non-standard information.
type Meta map[string]interface{}

// Organization defines model for Organization.
type Organization struct {
	// Id Organization UUID
	Id string `json:"id"`

	// IsDefault Whether this is the user's default organization
	IsDefault *bool `json:"is_default,omitempty"`

	// Name Organization display name
	Name string `json:"name"`

	// PreferredByAlgorithm Whether this organization is preferred by the automatic selection algorithm.
	// When remote_url is provided, the algorithm selects organizations based on:
	// - Access to the repository
	// - Number of projects/assets associated with the repository
	// - User's default organization preference
	PreferredByAlgorithm *bool `json:"preferred_by_algorithm,omitempty"`

	// ProjectCount Number of projects this organization has for the provided remote_url
	ProjectCount *int `json:"project_count,omitempty"`

	// Slug Organization slug (URL-friendly identifier)
	Slug string `json:"slug"`
}

// Policy defines model for Policy.
type Policy struct {
	// EnforcedAttributes Attributes that will override local settings (but may be allowed to edit)
	EnforcedAttributes *[]string `json:"enforced_attributes,omitempty"`

	// LockedAttributes List of attributes that cannot be overridden locally
	LockedAttributes *[]string `json:"locked_attributes,omitempty"`
}

// ProductConfig defines model for ProductConfig.
type ProductConfig struct {
	// Code Enable Code (SAST) scanning
	Code *bool `json:"code,omitempty"`

	// Container Enable Container scanning
	Container *bool `json:"container,omitempty"`

	// Iac Enable Infrastructure as Code scanning
	Iac *bool `json:"iac,omitempty"`

	// Oss Enable Open Source Software scanning
	Oss *bool `json:"oss,omitempty"`
}

// ProxyConfig defines model for ProxyConfig.
type ProxyConfig struct {
	// Http HTTP proxy URL
	Http *string `json:"http,omitempty"`

	// Https HTTPS proxy URL
	Https *string `json:"https,omitempty"`

	// Insecure Whether to skip SSL certificate validation
	Insecure *bool `json:"insecure,omitempty"`

	// NoProxy Comma-separated list of hosts to bypass proxy
	NoProxy *string `json:"no_proxy,omitempty"`
}

// QueryVersion Requested API version
type QueryVersion = string

// ResponseMeta defines model for ResponseMeta.
type ResponseMeta struct {
	// RequestTime Time when the request was processed
	RequestTime *time.Time `json:"request_time,omitempty"`
}

// ScanConfig defines model for ScanConfig.
type ScanConfig struct {
	// Automatic Enable automatic scanning
	Automatic *bool `json:"automatic,omitempty"`

	// NetNew Only scan net-new issues
	NetNew *bool `json:"net_new,omitempty"`
}

// SettingMetadata Metadata for a configuration setting when merged=true
type SettingMetadata struct {
	// Enforced When true, this setting value overrides all lower-scope settings.
	// Enforced settings from higher scopes take precedence over user settings.
	Enforced *bool `json:"enforced,omitempty"`

	// Locked When true, this setting cannot be edited by the user.
	// Locked settings are read-only in the UI.
	Locked *bool `json:"locked,omitempty"`

	// Origin The scope from which this setting value originates
	Origin SettingMetadataOrigin `json:"origin"`

	// Value The setting value (type depends on the specific setting)
	Value interface{} `json:"value"`
}

// SettingMetadataOrigin The scope from which this setting value originates
type SettingMetadataOrigin string

// TrustConfig defines model for TrustConfig.
type TrustConfig struct {
	// Enable Enable trust configuration
	Enable *bool `json:"enable,omitempty"`

	// TrustedFolders List of trusted folder paths (relative to target)
	TrustedFolders *[]string `json:"trusted_folders,omitempty"`
}

// UserConfigResponse Configuration response with per-setting metadata.
// When merged=false: returns settings for the specific scope only (no inheritance).
// When merged=true: returns merged settings with inheritance from higher scopes.
// Both modes use the same response structure with metadata for each setting.
type UserConfigResponse struct {
	Data struct {
		Attributes struct {
			// CreatedAt Timestamp when the configuration was created
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// FolderSettings Folder-level settings keyed by remote_url.
			// Each folder contains settings with per-setting metadata.
			FolderSettings *map[string]map[string]SettingMetadata `json:"folder_settings,omitempty"`

			// LastModifiedAt Timestamp of the last configuration update
			LastModifiedAt *time.Time `json:"last_modified_at,omitempty"`

			// Organizations Organizations available for the user. When remote_url is provided,
			// the preferred organization is indicated by preferred_by_algorithm.
			Organizations *[]Organization `json:"organizations,omitempty"`

			// Scope The scope of this configuration
			Scope *UserConfigResponseDataAttributesScope `json:"scope,omitempty"`

			// Settings Global-level settings with per-setting metadata.
			// Each setting has value, locked, enforced, and origin fields.
			Settings *map[string]SettingMetadata `json:"settings,omitempty"`
		} `json:"attributes"`

		// Id Unique identifier for this configuration instance
		Id   openapi_types.UUID         `json:"id"`
		Type UserConfigResponseDataType `json:"type"`
	} `json:"data"`
	Jsonapi *struct {
		Version *UserConfigResponseJsonapiVersion `json:"version,omitempty"`
	} `json:"jsonapi,omitempty"`
	Links *struct {
		// Self Link to this resource
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`
}

// UserConfigResponseDataAttributesScope The scope of this configuration
type UserConfigResponseDataAttributesScope string

// UserConfigResponseDataType defines model for UserConfigResponse.Data.Type.
type UserConfigResponseDataType string

// UserConfigResponseJsonapiVersion defines model for UserConfigResponse.Jsonapi.Version.
type UserConfigResponseJsonapiVersion string

// N400 defines model for 400.
type N400 = ErrorDocument

// N401 defines model for 401.
type N401 = ErrorDocument

// N404 defines model for 404.
type N404 = ErrorDocument

// N500 defines model for 500.
type N500 = ErrorDocument

// ErrorResponseApplicationJSON defines model for ErrorResponse.
type ErrorResponseApplicationJSON = ErrorDocument0

// ErrorResponseApplicationVndAPIPlusJSON defines model for ErrorResponse.
type ErrorResponseApplicationVndAPIPlusJSON = ErrorDocument0

// DeleteConfigParams defines parameters for DeleteConfig.
type DeleteConfigParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`

	// Tenant Endpoint address for tenant scope
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`

	// Group Group identifier
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Org Organization ID
	Org *string `form:"org,omitempty" json:"org,omitempty"`

	// AssetId Asset identifier
	AssetId *string `form:"asset_id,omitempty" json:"asset_id,omitempty"`

	// ProjectName Project name (alternative to asset_id when asset is not set)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty"`

	// RemoteUrl Repository URL
	RemoteUrl *string `form:"remote_url,omitempty" json:"remote_url,omitempty"`
}

// GetConfigParams defines parameters for GetConfig.
type GetConfigParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`

	// Org Organization ID
	Org *string `form:"org,omitempty" json:"org,omitempty"`

	// AssetId Asset identifier
	AssetId *string `form:"asset_id,omitempty" json:"asset_id,omitempty"`

	// ProjectName Project name (alternative to asset_id when asset is not set)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty"`

	// RemoteUrl Repository URL for automatic organization selection.
	// When provided, the service will attempt to find organizations that have access to this repository.
	// Supports various Git URL formats including HTTPS and SSH.
	RemoteUrl *string `form:"remote_url,omitempty" json:"remote_url,omitempty"`

	// Group Group identifier
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Tenant Endpoint address
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`

	// IntegrationName Name of the integration (e.g., VSCODE, INTELLIJ)
	IntegrationName *string `form:"integration_name,omitempty" json:"integration_name,omitempty"`

	// IntegrationVersion Version of the integration
	IntegrationVersion *string `form:"integration_version,omitempty" json:"integration_version,omitempty"`

	// IntegrationEnvironment Integration environment (e.g., platform)
	IntegrationEnvironment *string `form:"integration_environment,omitempty" json:"integration_environment,omitempty"`

	// IntegrationEnvironmentVersion Version of the integration environment
	IntegrationEnvironmentVersion *string `form:"integration_environment_version,omitempty" json:"integration_environment_version,omitempty"`

	// StartingAfter Return results starting after this cursor
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore Return results ending before this cursor
	EndingBefore *string `form:"ending_before,omitempty" json:"ending_before,omitempty"`

	// Limit Maximum number of results to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// UpdateConfigParams defines parameters for UpdateConfig.
type UpdateConfigParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`

	// Tenant Endpoint address for tenant scope
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`

	// Group Group identifier
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Org Organization ID
	Org *string `form:"org,omitempty" json:"org,omitempty"`

	// AssetId Asset identifier
	AssetId *string `form:"asset_id,omitempty" json:"asset_id,omitempty"`

	// ProjectName Project name (alternative to asset_id when asset is not set)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty"`

	// RemoteUrl Repository URL
	RemoteUrl *string `form:"remote_url,omitempty" json:"remote_url,omitempty"`
}

// CreateConfigParams defines parameters for CreateConfig.
type CreateConfigParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`

	// Tenant Endpoint address for tenant scope
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`

	// Group Group identifier
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Org Organization ID
	Org *string `form:"org,omitempty" json:"org,omitempty"`

	// AssetId Asset identifier
	AssetId *string `form:"asset_id,omitempty" json:"asset_id,omitempty"`

	// ProjectName Project name (alternative to asset_id when asset is not set)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty"`

	// RemoteUrl Repository URL
	RemoteUrl *string `form:"remote_url,omitempty" json:"remote_url,omitempty"`
}

// GetUserConfigParams defines parameters for GetUserConfig.
type GetUserConfigParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`

	// Tenant Tenant identifier to retrieve tenant-scope configuration.
	// When provided, returns configuration for the specified tenant instead of user config.
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`

	// Group Group UUID to retrieve group-scope configuration.
	// When provided, returns configuration for the specified group instead of user config.
	Group *openapi_types.UUID `form:"group,omitempty" json:"group,omitempty"`

	// Org Organization UUID to retrieve org-scope configuration.
	// When provided, returns configuration for the specified org instead of user config.
	Org *openapi_types.UUID `form:"org,omitempty" json:"org,omitempty"`

	// Merged When true, returns merged configuration with inheritance, precedence, and per-setting metadata.
	// When false (default), returns raw database values without metadata.
	Merged *bool `form:"merged,omitempty" json:"merged,omitempty"`

	// RemoteUrl Repository URL for automatic organization selection (used with merged=true).
	// When provided, the service will perform auto-org selection for folder-level settings.
	RemoteUrl *string `form:"remote_url,omitempty" json:"remote_url,omitempty"`

	// StartingAfter Return results starting after this cursor
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore Return results ending before this cursor
	EndingBefore *string `form:"ending_before,omitempty" json:"ending_before,omitempty"`

	// Limit Maximum number of results to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetConfigByIdParams defines parameters for GetConfigById.
type GetConfigByIdParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`

	// Merged When true, returns merged configuration with inheritance, precedence, and per-setting metadata.
	// When false (default), returns raw database values without metadata.
	Merged *bool `form:"merged,omitempty" json:"merged,omitempty"`

	// RemoteUrl Repository URL for automatic organization selection (used with merged=true).
	// When provided, the service will perform auto-org selection for folder-level settings.
	RemoteUrl *string `form:"remote_url,omitempty" json:"remote_url,omitempty"`
}

// UpdateConfigJSONRequestBody defines body for UpdateConfig for application/json ContentType.
type UpdateConfigJSONRequestBody = ConfigurationRequest

// CreateConfigJSONRequestBody defines body for CreateConfig for application/json ContentType.
type CreateConfigJSONRequestBody = ConfigurationRequest

// AsLinkProperty0 returns the union data inside the LinkProperty as a LinkProperty0
func (t LinkProperty) AsLinkProperty0() (LinkProperty0, error) {
	var body LinkProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkProperty0 overwrites any union data inside the LinkProperty as the provided LinkProperty0
func (t *LinkProperty) FromLinkProperty0(v LinkProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkProperty0 performs a merge with any union data inside the LinkProperty, using the provided LinkProperty0
func (t *LinkProperty) MergeLinkProperty0(v LinkProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkProperty1 returns the union data inside the LinkProperty as a LinkProperty1
func (t LinkProperty) AsLinkProperty1() (LinkProperty1, error) {
	var body LinkProperty1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkProperty1 overwrites any union data inside the LinkProperty as the provided LinkProperty1
func (t *LinkProperty) FromLinkProperty1(v LinkProperty1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkProperty1 performs a merge with any union data inside the LinkProperty, using the provided LinkProperty1
func (t *LinkProperty) MergeLinkProperty1(v LinkProperty1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LinkProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LinkProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteConfig request
	DeleteConfig(ctx context.Context, params *DeleteConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfigWithBody request with any body
	UpdateConfigWithBody(ctx context.Context, params *UpdateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfig(ctx context.Context, params *UpdateConfigParams, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConfigWithBody request with any body
	CreateConfigWithBody(ctx context.Context, params *CreateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConfig(ctx context.Context, params *CreateConfigParams, body CreateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAPIVersions request
	ListAPIVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAPIVersion request
	GetAPIVersion(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserConfig request
	GetUserConfig(ctx context.Context, params *GetUserConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigById request
	GetConfigById(ctx context.Context, id openapi_types.UUID, params *GetConfigByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteConfig(ctx context.Context, params *DeleteConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConfigRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigWithBody(ctx context.Context, params *UpdateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfig(ctx context.Context, params *UpdateConfigParams, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConfigWithBody(ctx context.Context, params *CreateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConfigRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConfig(ctx context.Context, params *CreateConfigParams, body CreateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConfigRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAPIVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAPIVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAPIVersion(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIVersionRequest(c.Server, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserConfig(ctx context.Context, params *GetUserConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserConfigRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigById(ctx context.Context, id openapi_types.UUID, params *GetConfigByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteConfigRequest generates requests for DeleteConfig
func NewDeleteConfigRequest(server string, params *DeleteConfigParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ldx_sync/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tenant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_id", runtime.ParamLocationQuery, *params.AssetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_name", runtime.ParamLocationQuery, *params.ProjectName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_url", runtime.ParamLocationQuery, *params.RemoteUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string, params *GetConfigParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ldx_sync/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_id", runtime.ParamLocationQuery, *params.AssetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_name", runtime.ParamLocationQuery, *params.ProjectName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_url", runtime.ParamLocationQuery, *params.RemoteUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tenant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntegrationName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integration_name", runtime.ParamLocationQuery, *params.IntegrationName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntegrationVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integration_version", runtime.ParamLocationQuery, *params.IntegrationVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntegrationEnvironment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integration_environment", runtime.ParamLocationQuery, *params.IntegrationEnvironment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntegrationEnvironmentVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integration_environment_version", runtime.ParamLocationQuery, *params.IntegrationEnvironmentVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConfigRequest calls the generic UpdateConfig builder with application/json body
func NewUpdateConfigRequest(server string, params *UpdateConfigParams, body UpdateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateConfigRequestWithBody generates requests for UpdateConfig with any type of body
func NewUpdateConfigRequestWithBody(server string, params *UpdateConfigParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ldx_sync/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tenant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_id", runtime.ParamLocationQuery, *params.AssetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_name", runtime.ParamLocationQuery, *params.ProjectName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_url", runtime.ParamLocationQuery, *params.RemoteUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateConfigRequest calls the generic CreateConfig builder with application/json body
func NewCreateConfigRequest(server string, params *CreateConfigParams, body CreateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConfigRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateConfigRequestWithBody generates requests for CreateConfig with any type of body
func NewCreateConfigRequestWithBody(server string, params *CreateConfigParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ldx_sync/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tenant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_id", runtime.ParamLocationQuery, *params.AssetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_name", runtime.ParamLocationQuery, *params.ProjectName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_url", runtime.ParamLocationQuery, *params.RemoteUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAPIVersionsRequest generates requests for ListAPIVersions
func NewListAPIVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAPIVersionRequest generates requests for GetAPIVersion
func NewGetAPIVersionRequest(server string, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserConfigRequest generates requests for GetUserConfig
func NewGetUserConfigRequest(server string, params *GetUserConfigParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/remote_client_connector/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tenant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Merged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "merged", runtime.ParamLocationQuery, *params.Merged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_url", runtime.ParamLocationQuery, *params.RemoteUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigByIdRequest generates requests for GetConfigById
func NewGetConfigByIdRequest(server string, id openapi_types.UUID, params *GetConfigByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/remote_client_connector/config/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Merged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "merged", runtime.ParamLocationQuery, *params.Merged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_url", runtime.ParamLocationQuery, *params.RemoteUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteConfigWithResponse request
	DeleteConfigWithResponse(ctx context.Context, params *DeleteConfigParams, reqEditors ...RequestEditorFn) (*DeleteConfigResponse, error)

	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// UpdateConfigWithBodyWithResponse request with any body
	UpdateConfigWithBodyWithResponse(ctx context.Context, params *UpdateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	UpdateConfigWithResponse(ctx context.Context, params *UpdateConfigParams, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	// CreateConfigWithBodyWithResponse request with any body
	CreateConfigWithBodyWithResponse(ctx context.Context, params *CreateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConfigResponse, error)

	CreateConfigWithResponse(ctx context.Context, params *CreateConfigParams, body CreateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConfigResponse, error)

	// ListAPIVersionsWithResponse request
	ListAPIVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAPIVersionsResponse, error)

	// GetAPIVersionWithResponse request
	GetAPIVersionWithResponse(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*GetAPIVersionResponse, error)

	// GetUserConfigWithResponse request
	GetUserConfigWithResponse(ctx context.Context, params *GetUserConfigParams, reqEditors ...RequestEditorFn) (*GetUserConfigResponse, error)

	// GetConfigByIdWithResponse request
	GetConfigByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetConfigByIdParams, reqEditors ...RequestEditorFn) (*GetConfigByIdResponse, error)
}

type DeleteConfigResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON401                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponseApplicationVndAPIPlusJSON
	JSON404                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON404 *ErrorResponseApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponseApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r DeleteConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *ConfigResponse
	ApplicationvndApiJSON200 *ConfigResponse
	JSON400                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON400 *ErrorResponseApplicationVndAPIPlusJSON
	JSON401                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponseApplicationVndAPIPlusJSON
	JSON404                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON404 *ErrorResponseApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponseApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *ConfigResponse
	ApplicationvndApiJSON200 *ConfigResponse
	JSON400                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON400 *ErrorResponseApplicationVndAPIPlusJSON
	JSON401                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponseApplicationVndAPIPlusJSON
	JSON404                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON404 *ErrorResponseApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponseApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r UpdateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConfigResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON201                  *ConfigResponse
	ApplicationvndApiJSON201 *ConfigResponse
	JSON400                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON400 *ErrorResponseApplicationVndAPIPlusJSON
	JSON401                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponseApplicationVndAPIPlusJSON
	JSON409                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON409 *ErrorResponseApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponseApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r CreateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAPIVersionsResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *[]string
	ApplicationvndApiJSON400 *N400
	ApplicationvndApiJSON401 *N401
	ApplicationvndApiJSON404 *N404
	ApplicationvndApiJSON500 *N500
}

// Status returns HTTPResponse.Status
func (r ListAPIVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAPIVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAPIVersionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *map[string]interface{}
	ApplicationvndApiJSON400 *N400
	ApplicationvndApiJSON401 *N401
	ApplicationvndApiJSON404 *N404
	ApplicationvndApiJSON500 *N500
}

// Status returns HTTPResponse.Status
func (r GetAPIVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserConfigResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *UserConfigResponse
	ApplicationvndApiJSON200 *UserConfigResponse
	JSON400                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON400 *ErrorResponseApplicationVndAPIPlusJSON
	JSON401                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponseApplicationVndAPIPlusJSON
	JSON404                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON404 *ErrorResponseApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponseApplicationVndAPIPlusJSON
	JSON501                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON501 *ErrorResponseApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r GetUserConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigByIdResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *UserConfigResponse
	ApplicationvndApiJSON200 *UserConfigResponse
	JSON400                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON400 *ErrorResponseApplicationVndAPIPlusJSON
	JSON401                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponseApplicationVndAPIPlusJSON
	JSON403                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON403 *ErrorResponseApplicationVndAPIPlusJSON
	JSON404                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON404 *ErrorResponseApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponseApplicationVndAPIPlusJSON
	JSON501                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON501 *ErrorResponseApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r GetConfigByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteConfigWithResponse request returning *DeleteConfigResponse
func (c *ClientWithResponses) DeleteConfigWithResponse(ctx context.Context, params *DeleteConfigParams, reqEditors ...RequestEditorFn) (*DeleteConfigResponse, error) {
	rsp, err := c.DeleteConfig(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConfigResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// UpdateConfigWithBodyWithResponse request with arbitrary body returning *UpdateConfigResponse
func (c *ClientWithResponses) UpdateConfigWithBodyWithResponse(ctx context.Context, params *UpdateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfigWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigWithResponse(ctx context.Context, params *UpdateConfigParams, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfig(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

// CreateConfigWithBodyWithResponse request with arbitrary body returning *CreateConfigResponse
func (c *ClientWithResponses) CreateConfigWithBodyWithResponse(ctx context.Context, params *CreateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConfigResponse, error) {
	rsp, err := c.CreateConfigWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConfigResponse(rsp)
}

func (c *ClientWithResponses) CreateConfigWithResponse(ctx context.Context, params *CreateConfigParams, body CreateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConfigResponse, error) {
	rsp, err := c.CreateConfig(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConfigResponse(rsp)
}

// ListAPIVersionsWithResponse request returning *ListAPIVersionsResponse
func (c *ClientWithResponses) ListAPIVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAPIVersionsResponse, error) {
	rsp, err := c.ListAPIVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAPIVersionsResponse(rsp)
}

// GetAPIVersionWithResponse request returning *GetAPIVersionResponse
func (c *ClientWithResponses) GetAPIVersionWithResponse(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*GetAPIVersionResponse, error) {
	rsp, err := c.GetAPIVersion(ctx, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIVersionResponse(rsp)
}

// GetUserConfigWithResponse request returning *GetUserConfigResponse
func (c *ClientWithResponses) GetUserConfigWithResponse(ctx context.Context, params *GetUserConfigParams, reqEditors ...RequestEditorFn) (*GetUserConfigResponse, error) {
	rsp, err := c.GetUserConfig(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserConfigResponse(rsp)
}

// GetConfigByIdWithResponse request returning *GetConfigByIdResponse
func (c *ClientWithResponses) GetConfigByIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetConfigByIdParams, reqEditors ...RequestEditorFn) (*GetConfigByIdResponse, error) {
	rsp, err := c.GetConfigById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigByIdResponse(rsp)
}

// ParseDeleteConfigResponse parses an HTTP response from a DeleteConfigWithResponse call
func ParseDeleteConfigResponse(rsp *http.Response) (*DeleteConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 404:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 404:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 404:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 200:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 404:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateConfigResponse parses an HTTP response from a UpdateConfigWithResponse call
func ParseUpdateConfigResponse(rsp *http.Response) (*UpdateConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 404:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 200:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 404:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseCreateConfigResponse parses an HTTP response from a CreateConfigWithResponse call
func ParseCreateConfigResponse(rsp *http.Response) (*CreateConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 201:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 409:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 201:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 409:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON409 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseListAPIVersionsResponse parses an HTTP response from a ListAPIVersionsWithResponse call
func ParseListAPIVersionsResponse(rsp *http.Response) (*ListAPIVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAPIVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetAPIVersionResponse parses an HTTP response from a GetAPIVersionWithResponse call
func ParseGetAPIVersionResponse(rsp *http.Response) (*GetAPIVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserConfigResponse parses an HTTP response from a GetUserConfigWithResponse call
func ParseGetUserConfigResponse(rsp *http.Response) (*GetUserConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest UserConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 404:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 501:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 200:
		var dest UserConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 404:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 501:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON501 = &dest

	}

	return response, nil
}

// ParseGetConfigByIdResponse parses an HTTP response from a GetConfigByIdWithResponse call
func ParseGetConfigByIdResponse(rsp *http.Response) (*GetConfigByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest UserConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 403:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 404:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 501:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 200:
		var dest UserConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 403:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON403 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 404:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 501:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON501 = &dest

	}

	return response, nil
}
