// Package v20241015 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v20241015

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ConfigAttributesScope.
const (
	Asset       ConfigAttributesScope = "asset"
	Global      ConfigAttributesScope = "global"
	Group       ConfigAttributesScope = "group"
	Org         ConfigAttributesScope = "org"
	ProjectName ConfigAttributesScope = "project_name"
	RemoteUrl   ConfigAttributesScope = "remote_url"
	Tenant      ConfigAttributesScope = "tenant"
)

// Defines values for ConfigDataAuthenticationMethod.
const (
	Oauth ConfigDataAuthenticationMethod = "oauth"
	Pat   ConfigDataAuthenticationMethod = "pat"
	Token ConfigDataAuthenticationMethod = "token"
)

// Defines values for ConfigResourceType.
const (
	ConfigResourceTypeConfig ConfigResourceType = "config"
)

// Defines values for ConfigResponseJsonapiVersion.
const (
	ConfigResponseJsonapiVersionN10 ConfigResponseJsonapiVersion = "1.0"
)

// Defines values for ConfigurationRequestDataType.
const (
	ConfigurationRequestDataTypeConfig ConfigurationRequestDataType = "config"
)

// Defines values for ErrorDocument0JsonapiVersion.
const (
	ErrorDocument0JsonapiVersionN10 ErrorDocument0JsonapiVersion = "1.0"
)

// Defines values for LogMessageLevel.
const (
	LogMessageLevelDebug LogMessageLevel = "debug"
	LogMessageLevelError LogMessageLevel = "error"
	LogMessageLevelInfo  LogMessageLevel = "info"
	LogMessageLevelWarn  LogMessageLevel = "warn"
)

// Defines values for LogPostingErrorDocumentJsonapiVersion.
const (
	LogPostingErrorDocumentJsonapiVersionN10 LogPostingErrorDocumentJsonapiVersion = "1.0"
)

// Defines values for PostLogResponseDataType.
const (
	Log PostLogResponseDataType = "log"
)

// Defines values for PostLogResponseJsonapiVersion.
const (
	PostLogResponseJsonapiVersionN10 PostLogResponseJsonapiVersion = "1.0"
)

// ActualVersion Resolved API version
type ActualVersion = string

// AttributeSource Configuration location sources
type AttributeSource struct {
	// Asset Asset-level configuration sources
	Asset *[]string `json:"asset,omitempty"`

	// Group Group-level configuration sources
	Group *[]string `json:"group,omitempty"`

	// Org Organization-level configuration sources
	Org *[]string `json:"org,omitempty"`

	// ProjectName Project name configuration sources (used when asset is not set)
	ProjectName *[]string `json:"project_name,omitempty"`

	// RemoteUrl repo-level configuration sources
	RemoteUrl *[]string `json:"remote_url,omitempty"`

	// Tenant Tenant-level configuration sources
	Tenant *[]string `json:"tenant,omitempty"`
}

// BinaryManagementConfig defines model for BinaryManagementConfig.
type BinaryManagementConfig struct {
	// AutomaticDownload Whether to automatically download CLI updates
	AutomaticDownload *bool `json:"automatic_download,omitempty"`

	// CliPath Path to the Snyk CLI binary
	CliPath *string `json:"cli_path,omitempty"`
}

// CodeAction defines model for CodeAction.
type CodeAction struct {
	// Enabled Whether the code action is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

// ConfigAttributes defines model for ConfigAttributes.
type ConfigAttributes struct {
	// AttributeSource Configuration location sources
	AttributeSource AttributeSource `json:"attribute_source"`
	ConfigData      ConfigData      `json:"config_data"`

	// CreatedAt Timestamp when the configuration was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// LastModifiedAt Timestamp of the last configuration update
	LastModifiedAt time.Time `json:"last_modified_at"`
	Policy         *Policy   `json:"policy,omitempty"`

	// Scope The highest scope level of the returned configuration
	Scope ConfigAttributesScope `json:"scope"`
}

// ConfigAttributesScope The highest scope level of the returned configuration
type ConfigAttributesScope string

// ConfigData defines model for ConfigData.
type ConfigData struct {
	// AuthenticationMethod Authentication method to use
	AuthenticationMethod *ConfigDataAuthenticationMethod `json:"authentication_method,omitempty"`
	Endpoints            *Endpoints                      `json:"endpoints,omitempty"`
	FilterConfig         *FilterConfig                   `json:"filter_config,omitempty"`
	FolderConfigs        *FolderConfigs                  `json:"folder_configs,omitempty"`

	// IdeConfigs Map of IDE configurations keyed by integration_name
	IdeConfigs *IdeConfigs `json:"ide_configs,omitempty"`

	// Organizations This list includes all organizations the user has access to.
	Organizations *[]Organization `json:"organizations,omitempty"`
	ProxyConfig   *ProxyConfig    `json:"proxy_config,omitempty"`
}

// ConfigDataAuthenticationMethod Authentication method to use
type ConfigDataAuthenticationMethod string

// ConfigResource defines model for ConfigResource.
type ConfigResource struct {
	Attributes ConfigAttributes `json:"attributes"`

	// Id Unique identifier for this configuration instance
	Id openapi_types.UUID `json:"id"`

	// Type Resource type
	Type ConfigResourceType `json:"type"`
}

// ConfigResourceType Resource type
type ConfigResourceType string

// ConfigResponse defines model for ConfigResponse.
type ConfigResponse struct {
	Data    ConfigResource `json:"data"`
	Jsonapi *struct {
		Version *ConfigResponseJsonapiVersion `json:"version,omitempty"`
	} `json:"jsonapi,omitempty"`
	Links *struct {
		// Self Link to this resource
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`
	Meta *ResponseMeta `json:"meta,omitempty"`
}

// ConfigResponseJsonapiVersion defines model for ConfigResponse.Jsonapi.Version.
type ConfigResponseJsonapiVersion string

// ConfigurationRequest Configuration request object for creating or updating configurations.
// For PATCH operations, only provided fields will be updated.
type ConfigurationRequest struct {
	Data struct {
		Attributes struct {
			ConfigData *ConfigData `json:"config_data,omitempty"`
			Policy     *Policy     `json:"policy,omitempty"`
		} `json:"attributes"`

		// Type Resource type
		Type ConfigurationRequestDataType `json:"type"`
	} `json:"data"`
}

// ConfigurationRequestDataType Resource type
type ConfigurationRequestDataType string

// Endpoints defines model for Endpoints.
type Endpoints struct {
	// ApiEndpoint Snyk API endpoint
	ApiEndpoint *string `json:"api_endpoint,omitempty"`

	// CodeEndpoint Snyk Code API endpoint
	CodeEndpoint *string `json:"code_endpoint,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Code An application-specific error code, expressed as a string value.
	Code *string `json:"code,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Id A unique identifier for this particular occurrence of the problem.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Links A link that leads to further details about this particular occurrance of the problem.
	Links  *ErrorLink              `json:"links,omitempty"`
	Meta   *map[string]interface{} `json:"meta,omitempty"`
	Source *struct {
		// Parameter A string indicating which URI query parameter caused the error.
		Parameter *string `json:"parameter,omitempty"`

		// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
		Pointer *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `json:"title,omitempty"`
}

// ErrorDocument defines model for ErrorDocument.
type ErrorDocument struct {
	Errors  []Error `json:"errors"`
	Jsonapi JsonApi `json:"jsonapi"`
}

// ErrorDocument0 defines model for ErrorDocument__0.
type ErrorDocument0 struct {
	Errors  []Error0 `json:"errors"`
	Jsonapi *struct {
		Version *ErrorDocument0JsonapiVersion `json:"version,omitempty"`
	} `json:"jsonapi,omitempty"`
}

// ErrorDocument0JsonapiVersion defines model for ErrorDocument0.Jsonapi.Version.
type ErrorDocument0JsonapiVersion string

// ErrorLink A link that leads to further details about this particular occurrance of the problem.
type ErrorLink struct {
	About *LinkProperty `json:"about,omitempty"`
}

// Error0 defines model for Error__0.
type Error0 struct {
	// Code An application-specific error code
	Code *string `json:"code,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem
	Detail string `json:"detail"`

	// Id A unique identifier for this particular occurrence of the problem
	Id    *openapi_types.UUID `json:"id,omitempty"`
	Links *struct {
		// About A link that leads to further details about this particular occurrence of the problem
		About *string `json:"about,omitempty"`
	} `json:"links,omitempty"`

	// Meta Additional error metadata
	Meta   *map[string]interface{} `json:"meta,omitempty"`
	Source *struct {
		// Parameter A string indicating which query parameter caused the error
		Parameter *string `json:"parameter,omitempty"`

		// Pointer A JSON Pointer to the value in the request that caused the error
		Pointer *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem
	Title *string `json:"title,omitempty"`
}

// FilterConfig defines model for FilterConfig.
type FilterConfig struct {
	// Cve CVE IDs to filter
	Cve *[]string `json:"cve,omitempty"`

	// Cwe CWE IDs to filter
	Cwe *[]string `json:"cwe,omitempty"`

	// RiskScoreThreshold Minimum risk score to display
	RiskScoreThreshold *int `json:"risk_score_threshold,omitempty"`

	// Rule Rule IDs to filter
	Rule       *[]string `json:"rule,omitempty"`
	Severities *struct {
		Critical *bool `json:"critical,omitempty"`
		High     *bool `json:"high,omitempty"`
		Low      *bool `json:"low,omitempty"`
		Medium   *bool `json:"medium,omitempty"`
	} `json:"severities,omitempty"`
}

// FolderConfig defines model for FolderConfig.
type FolderConfig struct {
	// AdditionalEnvironment Additional environment variables
	AdditionalEnvironment *[]string `json:"additional_environment,omitempty"`

	// AdditionalParameters Additional CLI parameters
	AdditionalParameters *[]string `json:"additional_parameters,omitempty"`

	// FolderPath Folder path relative to remote_url
	FolderPath string `json:"folder_path"`

	// Organizations This list includes only organizations
	// that have access to the specified repository, sorted by relevance.
	// The preferred organization is marked with preferred_by_algorithm: true.
	Organizations *[]Organization `json:"organizations,omitempty"`

	// PostScanExecuteCommand Command to execute after scanning
	PostScanExecuteCommand *string `json:"post_scan_execute_command,omitempty"`

	// PreScanExecuteCommand Command to execute before scanning
	PreScanExecuteCommand *string `json:"pre_scan_execute_command,omitempty"`

	// ReferenceBranch Git reference branch
	ReferenceBranch *string `json:"reference_branch,omitempty"`

	// ReferenceFolder Reference folder path relative to remote_url
	ReferenceFolder *string `json:"reference_folder,omitempty"`

	// RemoteUrl Repository URL
	// Supports various Git URL formats including HTTPS and SSH.
	RemoteUrl string `json:"remote_url"`
}

// FolderConfigs defines model for FolderConfigs.
type FolderConfigs = []FolderConfig

// IdeConfig defines model for IdeConfig.
type IdeConfig struct {
	// AutoConfigureMcpServer Configure Snyk MCP server
	AutoConfigureMcpServer *bool                   `json:"auto_configure_mcp_server,omitempty"`
	BinaryManagementConfig *BinaryManagementConfig `json:"binary_management_config,omitempty"`
	CodeActions            *struct {
		OpenBrowser     *CodeAction `json:"open_browser,omitempty"`
		OpenLearnLesson *CodeAction `json:"open_learn_lesson,omitempty"`
		ScaUpgrade      *CodeAction `json:"sca_upgrade,omitempty"`
	} `json:"code_actions,omitempty"`

	// HoverVerbosity Verbosity level for hover information
	HoverVerbosity *int `json:"hover_verbosity,omitempty"`

	// IntegrationName Name of the IDE integration
	IntegrationName *string          `json:"integration_name,omitempty"`
	IssueViewConfig *IssueViewConfig `json:"issue_view_config,omitempty"`

	// PersistRulesInProjects Write Snyk rules to current project. False will write it globally to user profile.
	PersistRulesInProjects *bool          `json:"persist_rules_in_projects,omitempty"`
	ProductConfig          *ProductConfig `json:"product_config,omitempty"`

	// PublishSecurityAtInceptionRules Publish Security at Inception rules
	PublishSecurityAtInceptionRules *bool        `json:"publish_security_at_inception_rules,omitempty"`
	ScanConfig                      *ScanConfig  `json:"scan_config,omitempty"`
	TrustConfig                     *TrustConfig `json:"trust_config,omitempty"`
}

// IdeConfigs Map of IDE configurations keyed by integration_name
type IdeConfigs map[string]IdeConfig

// IssueViewConfig defines model for IssueViewConfig.
type IssueViewConfig struct {
	// IgnoredIssues Show ignored issues
	IgnoredIssues *bool `json:"ignored_issues,omitempty"`

	// OpenIssues Show open issues
	OpenIssues *bool `json:"open_issues,omitempty"`
}

// JsonApi defines model for JsonApi.
type JsonApi struct {
	// Version Version of the JSON API specification this server supports.
	Version string `json:"version"`
}

// LinkProperty defines model for LinkProperty.
type LinkProperty struct {
	union json.RawMessage
}

// LinkProperty0 A string containing the link’s URL.
type LinkProperty0 = string

// LinkProperty1 defines model for .
type LinkProperty1 struct {
	// Href A string containing the link’s URL.
	Href string `json:"href"`

	// Meta Free-form object that may contain non-standard information.
	Meta *Meta `json:"meta,omitempty"`
}

// LogMessage A single log message
type LogMessage struct {
	// Level The log level
	Level *LogMessageLevel `json:"level,omitempty"`

	// LogMessage The log message content
	LogMessage *string `json:"log_message,omitempty"`
}

// LogMessageLevel The log level
type LogMessageLevel string

// LogPostingError defines model for LogPostingError.
type LogPostingError struct {
	// Detail A human-readable explanation specific to this occurrence of the problem
	Detail string `json:"detail"`

	// Status The HTTP status code applicable to this problem
	Status string `json:"status"`
}

// LogPostingErrorDocument defines model for LogPostingErrorDocument.
type LogPostingErrorDocument struct {
	Errors  []LogPostingError `json:"errors"`
	Jsonapi *struct {
		Version *LogPostingErrorDocumentJsonapiVersion `json:"version,omitempty"`
	} `json:"jsonapi,omitempty"`
}

// LogPostingErrorDocumentJsonapiVersion defines model for LogPostingErrorDocument.Jsonapi.Version.
type LogPostingErrorDocumentJsonapiVersion string

// LogSource Source information about the integration that generated all logs in this batch
type LogSource struct {
	// IntegrationEnvironment Environment where the integration is running
	IntegrationEnvironment *string `json:"integration_environment,omitempty"`

	// IntegrationEnvironmentVersion Version of the integration environment
	IntegrationEnvironmentVersion *string `json:"integration_environment_version,omitempty"`

	// IntegrationName Name of the integration (e.g., VS_CODE, JETBRAINS_IDE)
	IntegrationName *string `json:"integration_name,omitempty"`

	// IntegrationVersion Version of the integration
	IntegrationVersion *string `json:"integration_version,omitempty"`
}

// Meta Free-form object that may contain non-standard information.
type Meta map[string]interface{}

// Organization defines model for Organization.
type Organization struct {
	// Id Organization UUID
	Id string `json:"id"`

	// IsDefault Whether this is the user's default organization
	IsDefault *bool `json:"is_default,omitempty"`

	// Name Organization display name
	Name string `json:"name"`

	// PreferredByAlgorithm Whether this organization is preferred by the automatic selection algorithm.
	// When remote_url is provided, the algorithm selects organizations based on:
	// - Access to the repository
	// - Number of projects/assets associated with the repository
	// - User's default organization preference
	PreferredByAlgorithm *bool `json:"preferred_by_algorithm,omitempty"`

	// ProjectCount Number of projects this organization has for the provided remote_url
	ProjectCount *int `json:"project_count,omitempty"`

	// Slug Organization slug (URL-friendly identifier)
	Slug string `json:"slug"`
}

// Policy defines model for Policy.
type Policy struct {
	// EnforcedAttributes Attributes that will override local settings (but may be allowed to edit)
	EnforcedAttributes *[]string `json:"enforced_attributes,omitempty"`

	// LockedAttributes List of attributes that cannot be overridden locally
	LockedAttributes *[]string `json:"locked_attributes,omitempty"`
}

// PostLogResponse defines model for PostLogResponse.
type PostLogResponse struct {
	Data struct {
		// Id Unique identifier for the log entry
		Id openapi_types.UUID `json:"id"`

		// Type Resource type
		Type PostLogResponseDataType `json:"type"`
	} `json:"data"`
	Jsonapi *struct {
		Version *PostLogResponseJsonapiVersion `json:"version,omitempty"`
	} `json:"jsonapi,omitempty"`
	Links *struct {
		// Self Link to this resource
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`
	Meta *ResponseMeta `json:"meta,omitempty"`
}

// PostLogResponseDataType Resource type
type PostLogResponseDataType string

// PostLogResponseJsonapiVersion defines model for PostLogResponse.Jsonapi.Version.
type PostLogResponseJsonapiVersion string

// ProductConfig defines model for ProductConfig.
type ProductConfig struct {
	// Code Enable Code (SAST) scanning
	Code *bool `json:"code,omitempty"`

	// Container Enable Container scanning
	Container *bool `json:"container,omitempty"`

	// Iac Enable Infrastructure as Code scanning
	Iac *bool `json:"iac,omitempty"`

	// Oss Enable Open Source Software scanning
	Oss *bool `json:"oss,omitempty"`
}

// ProxyConfig defines model for ProxyConfig.
type ProxyConfig struct {
	// Http HTTP proxy URL
	Http *string `json:"http,omitempty"`

	// Https HTTPS proxy URL
	Https *string `json:"https,omitempty"`

	// Insecure Whether to skip SSL certificate validation
	Insecure *bool `json:"insecure,omitempty"`

	// NoProxy Comma-separated list of hosts to bypass proxy
	NoProxy *string `json:"no_proxy,omitempty"`
}

// QueryVersion Requested API version
type QueryVersion = string

// ResponseMeta defines model for ResponseMeta.
type ResponseMeta struct {
	// RequestTime Time when the request was processed
	RequestTime *time.Time `json:"request_time,omitempty"`
}

// ScanConfig defines model for ScanConfig.
type ScanConfig struct {
	// Automatic Enable automatic scanning
	Automatic *bool `json:"automatic,omitempty"`

	// NetNew Only scan net-new issues
	NetNew *bool `json:"net_new,omitempty"`
}

// TrustConfig defines model for TrustConfig.
type TrustConfig struct {
	// Enable Enable trust configuration
	Enable *bool `json:"enable,omitempty"`

	// TrustedFolders List of trusted folder paths (relative to target)
	TrustedFolders *[]string `json:"trusted_folders,omitempty"`
}

// N400 defines model for 400.
type N400 = ErrorDocument

// N401 defines model for 401.
type N401 = ErrorDocument

// N404 defines model for 404.
type N404 = ErrorDocument

// N500 defines model for 500.
type N500 = ErrorDocument

// ErrorResponseApplicationJSON defines model for ErrorResponse.
type ErrorResponseApplicationJSON = LogPostingErrorDocument

// ErrorResponseApplicationVndAPIPlusJSON defines model for ErrorResponse.
type ErrorResponseApplicationVndAPIPlusJSON = LogPostingErrorDocument

// ErrorResponse0ApplicationJSON defines model for ErrorResponse__0.
type ErrorResponse0ApplicationJSON = ErrorDocument0

// ErrorResponse0ApplicationVndAPIPlusJSON defines model for ErrorResponse__0.
type ErrorResponse0ApplicationVndAPIPlusJSON = ErrorDocument0

// DeleteConfigParams defines parameters for DeleteConfig.
type DeleteConfigParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`

	// Tenant Endpoint address for tenant scope
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`

	// Group Group identifier
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Org Organization ID
	Org *string `form:"org,omitempty" json:"org,omitempty"`

	// AssetId Asset identifier
	AssetId *string `form:"asset_id,omitempty" json:"asset_id,omitempty"`

	// ProjectName Project name (alternative to asset_id when asset is not set)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty"`

	// RemoteUrl Repository URL
	RemoteUrl *string `form:"remote_url,omitempty" json:"remote_url,omitempty"`
}

// GetConfigParams defines parameters for GetConfig.
type GetConfigParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`

	// Org Organization ID
	Org *string `form:"org,omitempty" json:"org,omitempty"`

	// AssetId Asset identifier
	AssetId *string `form:"asset_id,omitempty" json:"asset_id,omitempty"`

	// ProjectName Project name (alternative to asset_id when asset is not set)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty"`

	// RemoteUrl Repository URL for automatic organization selection.
	// When provided, the service will attempt to find organizations that have access to this repository.
	// Supports various Git URL formats including HTTPS and SSH.
	RemoteUrl *string `form:"remote_url,omitempty" json:"remote_url,omitempty"`

	// Group Group identifier
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Tenant Endpoint address
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`

	// IntegrationName Name of the integration (e.g., VSCODE, INTELLIJ)
	IntegrationName *string `form:"integration_name,omitempty" json:"integration_name,omitempty"`

	// IntegrationVersion Version of the integration
	IntegrationVersion *string `form:"integration_version,omitempty" json:"integration_version,omitempty"`

	// IntegrationEnvironment Integration environment (e.g., platform)
	IntegrationEnvironment *string `form:"integration_environment,omitempty" json:"integration_environment,omitempty"`

	// IntegrationEnvironmentVersion Version of the integration environment
	IntegrationEnvironmentVersion *string `form:"integration_environment_version,omitempty" json:"integration_environment_version,omitempty"`

	// StartingAfter Return results starting after this cursor
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore Return results ending before this cursor
	EndingBefore *string `form:"ending_before,omitempty" json:"ending_before,omitempty"`

	// Limit Maximum number of results to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// UpdateConfigParams defines parameters for UpdateConfig.
type UpdateConfigParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`

	// Tenant Endpoint address for tenant scope
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`

	// Group Group identifier
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Org Organization ID
	Org *string `form:"org,omitempty" json:"org,omitempty"`

	// AssetId Asset identifier
	AssetId *string `form:"asset_id,omitempty" json:"asset_id,omitempty"`

	// ProjectName Project name (alternative to asset_id when asset is not set)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty"`

	// RemoteUrl Repository URL
	RemoteUrl *string `form:"remote_url,omitempty" json:"remote_url,omitempty"`
}

// CreateConfigParams defines parameters for CreateConfig.
type CreateConfigParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`

	// Tenant Endpoint address for tenant scope
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`

	// Group Group identifier
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Org Organization ID
	Org *string `form:"org,omitempty" json:"org,omitempty"`

	// AssetId Asset identifier
	AssetId *string `form:"asset_id,omitempty" json:"asset_id,omitempty"`

	// ProjectName Project name (alternative to asset_id when asset is not set)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty"`

	// RemoteUrl Repository URL
	RemoteUrl *string `form:"remote_url,omitempty" json:"remote_url,omitempty"`
}

// CreateLogMessageJSONBody defines parameters for CreateLogMessage.
type CreateLogMessageJSONBody struct {
	LogMessages []LogMessage `json:"log_messages"`

	// Source Source information about the integration that generated all logs in this batch
	Source LogSource `json:"source"`
}

// CreateLogMessageParams defines parameters for CreateLogMessage.
type CreateLogMessageParams struct {
	// Version API version in format YYYY-MM-DD
	Version string `form:"version" json:"version"`
}

// UpdateConfigJSONRequestBody defines body for UpdateConfig for application/json ContentType.
type UpdateConfigJSONRequestBody = ConfigurationRequest

// CreateConfigJSONRequestBody defines body for CreateConfig for application/json ContentType.
type CreateConfigJSONRequestBody = ConfigurationRequest

// CreateLogMessageJSONRequestBody defines body for CreateLogMessage for application/json ContentType.
type CreateLogMessageJSONRequestBody CreateLogMessageJSONBody

// AsLinkProperty0 returns the union data inside the LinkProperty as a LinkProperty0
func (t LinkProperty) AsLinkProperty0() (LinkProperty0, error) {
	var body LinkProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkProperty0 overwrites any union data inside the LinkProperty as the provided LinkProperty0
func (t *LinkProperty) FromLinkProperty0(v LinkProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkProperty0 performs a merge with any union data inside the LinkProperty, using the provided LinkProperty0
func (t *LinkProperty) MergeLinkProperty0(v LinkProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkProperty1 returns the union data inside the LinkProperty as a LinkProperty1
func (t LinkProperty) AsLinkProperty1() (LinkProperty1, error) {
	var body LinkProperty1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkProperty1 overwrites any union data inside the LinkProperty as the provided LinkProperty1
func (t *LinkProperty) FromLinkProperty1(v LinkProperty1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkProperty1 performs a merge with any union data inside the LinkProperty, using the provided LinkProperty1
func (t *LinkProperty) MergeLinkProperty1(v LinkProperty1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LinkProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LinkProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteConfig request
	DeleteConfig(ctx context.Context, params *DeleteConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfigWithBody request with any body
	UpdateConfigWithBody(ctx context.Context, params *UpdateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfig(ctx context.Context, params *UpdateConfigParams, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConfigWithBody request with any body
	CreateConfigWithBody(ctx context.Context, params *CreateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConfig(ctx context.Context, params *CreateConfigParams, body CreateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogMessageWithBody request with any body
	CreateLogMessageWithBody(ctx context.Context, params *CreateLogMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogMessage(ctx context.Context, params *CreateLogMessageParams, body CreateLogMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAPIVersions request
	ListAPIVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAPIVersion request
	GetAPIVersion(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteConfig(ctx context.Context, params *DeleteConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConfigRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigWithBody(ctx context.Context, params *UpdateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfig(ctx context.Context, params *UpdateConfigParams, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConfigWithBody(ctx context.Context, params *CreateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConfigRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConfig(ctx context.Context, params *CreateConfigParams, body CreateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConfigRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogMessageWithBody(ctx context.Context, params *CreateLogMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogMessageRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogMessage(ctx context.Context, params *CreateLogMessageParams, body CreateLogMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogMessageRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAPIVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAPIVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAPIVersion(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIVersionRequest(c.Server, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteConfigRequest generates requests for DeleteConfig
func NewDeleteConfigRequest(server string, params *DeleteConfigParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ldx_sync/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tenant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_id", runtime.ParamLocationQuery, *params.AssetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_name", runtime.ParamLocationQuery, *params.ProjectName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_url", runtime.ParamLocationQuery, *params.RemoteUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string, params *GetConfigParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ldx_sync/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_id", runtime.ParamLocationQuery, *params.AssetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_name", runtime.ParamLocationQuery, *params.ProjectName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_url", runtime.ParamLocationQuery, *params.RemoteUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tenant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntegrationName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integration_name", runtime.ParamLocationQuery, *params.IntegrationName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntegrationVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integration_version", runtime.ParamLocationQuery, *params.IntegrationVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntegrationEnvironment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integration_environment", runtime.ParamLocationQuery, *params.IntegrationEnvironment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntegrationEnvironmentVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integration_environment_version", runtime.ParamLocationQuery, *params.IntegrationEnvironmentVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConfigRequest calls the generic UpdateConfig builder with application/json body
func NewUpdateConfigRequest(server string, params *UpdateConfigParams, body UpdateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateConfigRequestWithBody generates requests for UpdateConfig with any type of body
func NewUpdateConfigRequestWithBody(server string, params *UpdateConfigParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ldx_sync/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tenant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_id", runtime.ParamLocationQuery, *params.AssetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_name", runtime.ParamLocationQuery, *params.ProjectName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_url", runtime.ParamLocationQuery, *params.RemoteUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateConfigRequest calls the generic CreateConfig builder with application/json body
func NewCreateConfigRequest(server string, params *CreateConfigParams, body CreateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConfigRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateConfigRequestWithBody generates requests for CreateConfig with any type of body
func NewCreateConfigRequestWithBody(server string, params *CreateConfigParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ldx_sync/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Tenant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_id", runtime.ParamLocationQuery, *params.AssetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_name", runtime.ParamLocationQuery, *params.ProjectName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_url", runtime.ParamLocationQuery, *params.RemoteUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLogMessageRequest calls the generic CreateLogMessage builder with application/json body
func NewCreateLogMessageRequest(server string, params *CreateLogMessageParams, body CreateLogMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogMessageRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateLogMessageRequestWithBody generates requests for CreateLogMessage with any type of body
func NewCreateLogMessageRequestWithBody(server string, params *CreateLogMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/local_client_connector/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAPIVersionsRequest generates requests for ListAPIVersions
func NewListAPIVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAPIVersionRequest generates requests for GetAPIVersion
func NewGetAPIVersionRequest(server string, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteConfigWithResponse request
	DeleteConfigWithResponse(ctx context.Context, params *DeleteConfigParams, reqEditors ...RequestEditorFn) (*DeleteConfigResponse, error)

	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// UpdateConfigWithBodyWithResponse request with any body
	UpdateConfigWithBodyWithResponse(ctx context.Context, params *UpdateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	UpdateConfigWithResponse(ctx context.Context, params *UpdateConfigParams, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	// CreateConfigWithBodyWithResponse request with any body
	CreateConfigWithBodyWithResponse(ctx context.Context, params *CreateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConfigResponse, error)

	CreateConfigWithResponse(ctx context.Context, params *CreateConfigParams, body CreateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConfigResponse, error)

	// CreateLogMessageWithBodyWithResponse request with any body
	CreateLogMessageWithBodyWithResponse(ctx context.Context, params *CreateLogMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogMessageResponse, error)

	CreateLogMessageWithResponse(ctx context.Context, params *CreateLogMessageParams, body CreateLogMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogMessageResponse, error)

	// ListAPIVersionsWithResponse request
	ListAPIVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAPIVersionsResponse, error)

	// GetAPIVersionWithResponse request
	GetAPIVersionWithResponse(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*GetAPIVersionResponse, error)
}

type DeleteConfigResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON401                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON404                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON404 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponse0ApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r DeleteConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *ConfigResponse
	ApplicationvndApiJSON200 *ConfigResponse
	JSON400                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON400 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON401                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON404                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON404 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponse0ApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *ConfigResponse
	ApplicationvndApiJSON200 *ConfigResponse
	JSON400                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON400 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON401                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON404                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON404 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponse0ApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r UpdateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConfigResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON201                  *ConfigResponse
	ApplicationvndApiJSON201 *ConfigResponse
	JSON400                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON400 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON401                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON409                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON409 *ErrorResponse0ApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponse0ApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponse0ApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r CreateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogMessageResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON201                  *PostLogResponse
	ApplicationvndApiJSON201 *PostLogResponse
	JSON400                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON400 *ErrorResponseApplicationVndAPIPlusJSON
	JSON401                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON401 *ErrorResponseApplicationVndAPIPlusJSON
	JSON409                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON409 *ErrorResponseApplicationVndAPIPlusJSON
	JSON500                  *ErrorResponseApplicationJSON
	ApplicationvndApiJSON500 *ErrorResponseApplicationVndAPIPlusJSON
}

// Status returns HTTPResponse.Status
func (r CreateLogMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAPIVersionsResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *[]string
	ApplicationvndApiJSON400 *N400
	ApplicationvndApiJSON401 *N401
	ApplicationvndApiJSON404 *N404
	ApplicationvndApiJSON500 *N500
}

// Status returns HTTPResponse.Status
func (r ListAPIVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAPIVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAPIVersionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *map[string]interface{}
	ApplicationvndApiJSON400 *N400
	ApplicationvndApiJSON401 *N401
	ApplicationvndApiJSON404 *N404
	ApplicationvndApiJSON500 *N500
}

// Status returns HTTPResponse.Status
func (r GetAPIVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteConfigWithResponse request returning *DeleteConfigResponse
func (c *ClientWithResponses) DeleteConfigWithResponse(ctx context.Context, params *DeleteConfigParams, reqEditors ...RequestEditorFn) (*DeleteConfigResponse, error) {
	rsp, err := c.DeleteConfig(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConfigResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, params *GetConfigParams, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// UpdateConfigWithBodyWithResponse request with arbitrary body returning *UpdateConfigResponse
func (c *ClientWithResponses) UpdateConfigWithBodyWithResponse(ctx context.Context, params *UpdateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfigWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigWithResponse(ctx context.Context, params *UpdateConfigParams, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfig(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

// CreateConfigWithBodyWithResponse request with arbitrary body returning *CreateConfigResponse
func (c *ClientWithResponses) CreateConfigWithBodyWithResponse(ctx context.Context, params *CreateConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConfigResponse, error) {
	rsp, err := c.CreateConfigWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConfigResponse(rsp)
}

func (c *ClientWithResponses) CreateConfigWithResponse(ctx context.Context, params *CreateConfigParams, body CreateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConfigResponse, error) {
	rsp, err := c.CreateConfig(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConfigResponse(rsp)
}

// CreateLogMessageWithBodyWithResponse request with arbitrary body returning *CreateLogMessageResponse
func (c *ClientWithResponses) CreateLogMessageWithBodyWithResponse(ctx context.Context, params *CreateLogMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogMessageResponse, error) {
	rsp, err := c.CreateLogMessageWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogMessageResponse(rsp)
}

func (c *ClientWithResponses) CreateLogMessageWithResponse(ctx context.Context, params *CreateLogMessageParams, body CreateLogMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogMessageResponse, error) {
	rsp, err := c.CreateLogMessage(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogMessageResponse(rsp)
}

// ListAPIVersionsWithResponse request returning *ListAPIVersionsResponse
func (c *ClientWithResponses) ListAPIVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAPIVersionsResponse, error) {
	rsp, err := c.ListAPIVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAPIVersionsResponse(rsp)
}

// GetAPIVersionWithResponse request returning *GetAPIVersionResponse
func (c *ClientWithResponses) GetAPIVersionWithResponse(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*GetAPIVersionResponse, error) {
	rsp, err := c.GetAPIVersion(ctx, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIVersionResponse(rsp)
}

// ParseDeleteConfigResponse parses an HTTP response from a DeleteConfigWithResponse call
func ParseDeleteConfigResponse(rsp *http.Response) (*DeleteConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 404:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 404:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 400:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 404:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 200:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 400:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 404:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateConfigResponse parses an HTTP response from a UpdateConfigWithResponse call
func ParseUpdateConfigResponse(rsp *http.Response) (*UpdateConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 400:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 404:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 200:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 400:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 404:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseCreateConfigResponse parses an HTTP response from a CreateConfigWithResponse call
func ParseCreateConfigResponse(rsp *http.Response) (*CreateConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 201:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 400:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 409:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponse0ApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 201:
		var dest ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 400:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 409:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON409 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponse0ApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLogMessageResponse parses an HTTP response from a CreateLogMessageWithResponse call
func ParseCreateLogMessageResponse(rsp *http.Response) (*CreateLogMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 201:
		var dest PostLogResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 409:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 201:
		var dest PostLogResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON201 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 400:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 401:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 409:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON409 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.api+json" && rsp.StatusCode == 500:
		var dest ErrorResponseApplicationVndAPIPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseListAPIVersionsResponse parses an HTTP response from a ListAPIVersionsWithResponse call
func ParseListAPIVersionsResponse(rsp *http.Response) (*ListAPIVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAPIVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetAPIVersionResponse parses an HTTP response from a GetAPIVersionWithResponse call
func ParseGetAPIVersionResponse(rsp *http.Response) (*GetAPIVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}
