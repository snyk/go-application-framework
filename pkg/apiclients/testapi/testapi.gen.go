// Package testapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package testapi

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for CveProblemSource.
const (
	Cve CveProblemSource = "cve"
)

// Defines values for CweProblemSource.
const (
	Cwe CweProblemSource = "cwe"
)

// Defines values for DeepcodeBundleSubjectType.
const (
	DeepcodeBundle DeepcodeBundleSubjectType = "deepcode_bundle"
)

// Defines values for DepGraphSubjectType.
const (
	DepGraphSubjectTypeDepGraph DepGraphSubjectType = "dep_graph"
)

// Defines values for DepGraphSubjectCreateType.
const (
	DepGraphSubjectCreateTypeDepGraph DepGraphSubjectCreateType = "dep_graph"
)

// Defines values for DependencyPathEvidenceSource.
const (
	DependencyPath DependencyPathEvidenceSource = "dependency_path"
)

// Defines values for ExecutionFlowEvidenceSource.
const (
	ExecutionFlow ExecutionFlowEvidenceSource = "execution_flow"
)

// Defines values for FindingDataType.
const (
	Findings FindingDataType = "findings"
)

// Defines values for FindingType.
const (
	FindingTypeDast  FindingType = "dast"
	FindingTypeOther FindingType = "other"
	FindingTypeSast  FindingType = "sast"
	FindingTypeSca   FindingType = "sca"
)

// Defines values for FixAppliedOutcome.
const (
	FullyResolved     FixAppliedOutcome = "fully_resolved"
	PartiallyResolved FixAppliedOutcome = "partially_resolved"
	Unresolved        FixAppliedOutcome = "unresolved"
)

// Defines values for GitUrlCoordinatesSubjectType.
const (
	GitUrlCoordinates GitUrlCoordinatesSubjectType = "git_url_coordinates"
)

// Defines values for GithubSecurityAdvisoryProblemSource.
const (
	Ghsa GithubSecurityAdvisoryProblemSource = "ghsa"
)

// Defines values for IgnoreActionType.
const (
	IgnoreActionTypeIgnore IgnoreActionType = "ignore"
)

// Defines values for IgnoreDetailsReasonType.
const (
	NotVulnerable   IgnoreDetailsReasonType = "not-vulnerable"
	TemporaryIgnore IgnoreDetailsReasonType = "temporary-ignore"
	WontFix         IgnoreDetailsReasonType = "wont-fix"
)

// Defines values for JobDataType.
const (
	TestJobs JobDataType = "test_jobs"
)

// Defines values for JobRelationshipFieldDataType.
const (
	JobRelationshipFieldDataTypeTests JobRelationshipFieldDataType = "tests"
)

// Defines values for LocalPathLocatorType.
const (
	LocalPath LocalPathLocatorType = "local_path"
)

// Defines values for OtherEvidenceSource.
const (
	OtherEvidenceSourceOther OtherEvidenceSource = "other"
)

// Defines values for OtherLocationType.
const (
	OtherLocationTypeOther OtherLocationType = "other"
)

// Defines values for OtherLocatorType.
const (
	OtherLocatorTypeOther OtherLocatorType = "other"
)

// Defines values for OtherProblemSource.
const (
	OtherProblemSourceOther OtherProblemSource = "other"
)

// Defines values for OtherSubjectType.
const (
	OtherSubjectTypeOther OtherSubjectType = "other"
)

// Defines values for PackageLocationType.
const (
	PackageLocationTypePackage PackageLocationType = "package"
)

// Defines values for PassFail.
const (
	Fail PassFail = "fail"
	Pass PassFail = "pass"
)

// Defines values for PinPackageActionType.
const (
	PinPackage PinPackageActionType = "pin_package"
)

// Defines values for PolicyType.
const (
	LegacyPolicySnapshot PolicyType = "legacy_policy_snapshot"
)

// Defines values for PolicyRef0.
const (
	PolicyRef0LocalPolicy PolicyRef0 = "local_policy"
)

// Defines values for PolicyRuleReview.
const (
	PolicyRuleReviewApproved    PolicyRuleReview = "approved"
	PolicyRuleReviewCancelled   PolicyRuleReview = "cancelled"
	PolicyRuleReviewNotRequired PolicyRuleReview = "not-required"
	PolicyRuleReviewPending     PolicyRuleReview = "pending"
	PolicyRuleReviewRejected    PolicyRuleReview = "rejected"
)

// Defines values for ProjectEntityLocatorType.
const (
	ProjectEntity ProjectEntityLocatorType = "project_entity"
)

// Defines values for ProjectNameLocatorType.
const (
	ProjectName ProjectNameLocatorType = "project_name"
)

// Defines values for ReachabilityEvidenceSource.
const (
	Reachability ReachabilityEvidenceSource = "reachability"
)

// Defines values for ReachabilityFilter.
const (
	ReachabilityFilterNoInfo      ReachabilityFilter = "no_info"
	ReachabilityFilterNoPathFound ReachabilityFilter = "no_path_found"
	ReachabilityFilterReachable   ReachabilityFilter = "reachable"
)

// Defines values for ReachabilityType.
const (
	ReachabilityTypeFunction      ReachabilityType = "function"
	ReachabilityTypeNoInfo        ReachabilityType = "no_info"
	ReachabilityTypeNone          ReachabilityType = "none"
	ReachabilityTypeNotApplicable ReachabilityType = "not_applicable"
)

// Defines values for SbomReachabilitySubjectType.
const (
	SbomReachability SbomReachabilitySubjectType = "sbom_reachability"
)

// Defines values for SbomSubjectType.
const (
	Sbom SbomSubjectType = "sbom"
)

// Defines values for ScmRepoLocatorType.
const (
	ScmRepo ScmRepoLocatorType = "scm_repo"
)

// Defines values for Severity.
const (
	SeverityCritical Severity = "critical"
	SeverityHigh     Severity = "high"
	SeverityLow      Severity = "low"
	SeverityMedium   Severity = "medium"
	SeverityNone     Severity = "none"
	SeverityOther    Severity = "other"
)

// Defines values for SeverityChangeActionType.
const (
	SeverityChangeActionTypeSeverityChange SeverityChangeActionType = "severity-change"
)

// Defines values for SnykCloudRuleProblemSource.
const (
	SnykCloudRule SnykCloudRuleProblemSource = "snyk_cloud_rule"
)

// Defines values for SnykCodeRuleProblemSource.
const (
	SnykCodeRule SnykCodeRuleProblemSource = "snyk_code_rule"
)

// Defines values for SnykLicenseProblemSource.
const (
	SnykLicense SnykLicenseProblemSource = "snyk_license"
)

// Defines values for SnykPolicyRefOwner.
const (
	Group SnykPolicyRefOwner = "group"
	Org   SnykPolicyRefOwner = "org"
)

// Defines values for SnykVulnProblemSource.
const (
	SnykVuln SnykVulnProblemSource = "snyk_vuln"
)

// Defines values for SourceLocationType.
const (
	Source SourceLocationType = "source"
)

// Defines values for SuppressionStatus.
const (
	SuppressionStatusIgnored               SuppressionStatus = "ignored"
	SuppressionStatusOther                 SuppressionStatus = "other"
	SuppressionStatusPendingIgnoreApproval SuppressionStatus = "pending_ignore_approval"
)

// Defines values for TestDataType.
const (
	TestDataTypeTests TestDataType = "tests"
)

// Defines values for TestDataCreateType.
const (
	Tests TestDataCreateType = "tests"
)

// Defines values for TestExecutionStates.
const (
	TestExecutionStatesErrored  TestExecutionStates = "errored"
	TestExecutionStatesFinished TestExecutionStates = "finished"
	TestExecutionStatesPending  TestExecutionStates = "pending"
	TestExecutionStatesStarted  TestExecutionStates = "started"
)

// Defines values for TestOutcomeReason.
const (
	TestOutcomeReasonOther        TestOutcomeReason = "other"
	TestOutcomeReasonPolicyBreach TestOutcomeReason = "policy_breach"
	TestOutcomeReasonTimeout      TestOutcomeReason = "timeout"
)

// Defines values for UpgradePackageActionType.
const (
	UpgradePackage UpgradePackageActionType = "upgrade_package"
)

// Defines values for IoSnykApiCommonJsonApiVersion.
const (
	N10 IoSnykApiCommonJsonApiVersion = "1.0"
)

// Defines values for SnykvulndbBuildPackageEcosystemType.
const (
	Build SnykvulndbBuildPackageEcosystemType = "build"
)

// Defines values for SnykvulndbCvssSourceType.
const (
	SnykvulndbCvssSourceTypeOther     SnykvulndbCvssSourceType = "other"
	SnykvulndbCvssSourceTypePrimary   SnykvulndbCvssSourceType = "primary"
	SnykvulndbCvssSourceTypeSecondary SnykvulndbCvssSourceType = "secondary"
)

// Defines values for SnykvulndbOsPackageEcosystemType.
const (
	Os SnykvulndbOsPackageEcosystemType = "os"
)

// Defines values for SnykvulndbOtherPackageEcosystemType.
const (
	Other SnykvulndbOtherPackageEcosystemType = "other"
)

// Action Different types of managed OS package fix actions
type Action struct {
	union json.RawMessage
}

// ActualVersion Resolved API version
type ActualVersion = string

// AppliedPolicy defines model for AppliedPolicy.
type AppliedPolicy struct {
	union json.RawMessage
}

// CveProblem CVE designation according to the public Common Vulnerability Exposure
// database.
type CveProblem struct {
	Id     string           `json:"id"`
	Source CveProblemSource `json:"source"`
}

// CveProblemSource defines model for CveProblem.Source.
type CveProblemSource string

// CweProblem CWE classification according to MITRE's Common Weakness Enumeration (CWE)
// database.
type CweProblem struct {
	Id     string           `json:"id"`
	Source CweProblemSource `json:"source"`
}

// CweProblemSource defines model for CweProblem.Source.
type CweProblemSource string

// DeepcodeBundleSubject Test subject representing source code uploaded to Snyk using DeepCode
// bundle APIs.
type DeepcodeBundleSubject struct {
	// BundleId Deepcode Bundle ID. These IDs are sha256 digests (32 bytes or 64 hex digits).
	BundleId string `json:"bundle_id"`

	// Locator Locate local paths from which the source code bundle was derived.
	Locator LocalPathLocator          `json:"locator"`
	Type    DeepcodeBundleSubjectType `json:"type"`
}

// DeepcodeBundleSubjectType defines model for DeepcodeBundleSubject.Type.
type DeepcodeBundleSubjectType string

// DepGraphSubject Test subject representing a Snyk dependency graph (a legacy SBOM format).
type DepGraphSubject struct {
	// Locator Source file(s) from which the dependency graph was derived.
	//
	// For some managed package ecosystems (examples: Maven, Yarn workspaces),
	// Snyk might derive a dependency graph from several files.
	Locator LocalPathLocator    `json:"locator"`
	Type    DepGraphSubjectType `json:"type"`
}

// DepGraphSubjectType defines model for DepGraphSubject.Type.
type DepGraphSubjectType string

// DepGraphSubjectCreate Test subject representing a Snyk dependency graph (a legacy SBOM format).
type DepGraphSubjectCreate struct {
	// DepGraph When creating a test, provide the dep-graph contents inline to the request.
	//
	// This attribute is only available when creating a new Test.
	DepGraph IoSnykApiV1testdepgraphRequestDepGraph `json:"dep_graph"`

	// Locator Source file(s) from which the dependency graph was derived.
	//
	// For some managed package ecosystems (examples: Maven, Yarn workspaces),
	// Snyk might derive a dependency graph from several files.
	Locator LocalPathLocator          `json:"locator"`
	Type    DepGraphSubjectCreateType `json:"type"`
}

// DepGraphSubjectCreateType defines model for DepGraphSubjectCreate.Type.
type DepGraphSubjectCreateType string

// DependencyPathEvidence Dependency path to a software component within an SBOM dependency graph.
//
// Finding types: SCA
type DependencyPathEvidence struct {
	// Path Series of component identifiers starting from the top-level component tested,
	// and ending in the vulnerable software component.
	//
	// The identifiers are domain-specific and determined by the test subject.
	Path   []Package                    `json:"path"`
	Source DependencyPathEvidenceSource `json:"source"`
}

// DependencyPathEvidenceSource defines model for DependencyPathEvidence.Source.
type DependencyPathEvidenceSource string

// Error defines model for Error.
type Error struct {
	// Code An application-specific error code, expressed as a string value.
	Code *string `json:"code,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Id A unique identifier for this particular occurrence of the problem.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Links A link that leads to further details about this particular occurrance of the problem.
	Links  *ErrorLink              `json:"links,omitempty"`
	Meta   *map[string]interface{} `json:"meta,omitempty"`
	Source *struct {
		// Parameter A string indicating which URI query parameter caused the error.
		Parameter *string `json:"parameter,omitempty"`

		// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
		Pointer *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `json:"title,omitempty"`
}

// ErrorDocument defines model for ErrorDocument.
type ErrorDocument struct {
	Errors  []Error `json:"errors"`
	Jsonapi JsonApi `json:"jsonapi"`
}

// ErrorLink A link that leads to further details about this particular occurrance of the problem.
type ErrorLink struct {
	About *LinkProperty `json:"about,omitempty"`
}

// Evidence Supporting evidence for (rather than representative of) the finding in other
// security domains and systems, lacking a well-known identifier.
//
// More detailed attributes may also be included inline, especially when this
// information is not yet generally available in a well-known public APIs.
//
// Examples include:
// - Detailed enumeration of dependency paths
// - Execution flows leading to a code rule violation
type Evidence struct {
	union json.RawMessage
}

// ExecutionFlowEvidence Indicate a program flow of execution as additional evidence for the finding.
type ExecutionFlowEvidence struct {
	// Flow Sequence of locations within this flow of execution.
	//
	// For example, a sequence of locations connecting the "source" location
	// where input data is obtained, to a "sink" location where it is used.
	Flow   []FileRegion                `json:"flow"`
	Source ExecutionFlowEvidenceSource `json:"source"`
}

// ExecutionFlowEvidenceSource defines model for ExecutionFlowEvidence.Source.
type ExecutionFlowEvidenceSource string

// FileRegion FileRegion models a location where vulnerable code is found.
type FileRegion struct {
	// FilePath File path for the code snippet.
	FilePath string `json:"file_path"`

	// FromColumn Column on which the snippet starts.
	FromColumn *int `json:"from_column,omitempty"`

	// FromLine Line in the file where the code snippet starts.
	FromLine int `json:"from_line"`

	// ToColumn Column at which the code snippet ends.
	ToColumn *int `json:"to_column,omitempty"`

	// ToLine Line on which the code snippet ends.
	ToLine *int `json:"to_line,omitempty"`
}

// FindingAttributes FindingAttributes represent the attributes of a Finding resource.
type FindingAttributes struct {
	// CauseOfFailure Did this finding cause the test outcome to fail?
	CauseOfFailure bool `json:"cause_of_failure"`

	// Description A longer human-readable text description for this finding.
	Description string `json:"description"`

	// Evidence Supporting evidence for (rather than representative of) the finding in
	// other security domains and systems, lacking a well-known identifier.
	Evidence []Evidence `json:"evidence"`

	// FindingType Type of finding.
	FindingType FindingType `json:"finding_type"`

	// Key An opaque key used for aggregating the finding across multiple test
	// executions operating on the same or originating Asset.
	//
	// Findings within a Test execution are aggregated by this key.
	Key string `json:"key"`

	// Locations Locations in the Asset's contents where the finding may be found.
	Locations []FindingLocation `json:"locations"`

	// PolicyModifications Attributes which have been modified by policy decisions.
	PolicyModifications *[]PolicyModification `json:"policy_modifications,omitempty"`

	// Problems Problems are representative of the finding in other security domains and
	// systems with a well-known identifier.
	Problems []Problem `json:"problems"`

	// Rating Qualitative ratings on a finding.
	Rating Rating `json:"rating"`

	// Risk Qualitative risk analysis on a finding.
	Risk Risk `json:"risk"`

	// Suppression Indication of whether a finding is suppressed by a policy decision.
	Suppression *Suppression `json:"suppression,omitempty"`

	// Title A human-readable title for this finding.
	Title string `json:"title"`
}

// FindingData FindingData represents a Finding resource object.
type FindingData struct {
	Attributes *FindingAttributes  `json:"attributes,omitempty"`
	Id         *openapi_types.UUID `json:"id,omitempty"`

	// Links Links to external resources outside this API.
	//
	// Because these are not REST API resources, they are expressed here as links,
	// rather than as relationships.
	Links *struct {
		// SnykAdvisory Link to Snyk's vulnerability advisory for more information on the
		// finding, if applicable.
		SnykAdvisory *IoSnykApiCommonLinkProperty `json:"snyk_advisory,omitempty"`

		// SnykLearn Link to a Snyk Learn lesson relevant to the finding, if applicable.
		SnykLearn *IoSnykApiCommonLinkProperty `json:"snyk_learn,omitempty"`
	} `json:"links,omitempty"`
	Relationships *struct {
		// Asset Originating asset in which this finding was discovered.
		Asset *struct {
			Data *struct {
				Id   openapi_types.UUID `json:"id"`
				Type string             `json:"type"`
			} `json:"data,omitempty"`
			Links IoSnykApiCommonRelatedLink `json:"links"`

			// Meta Free-form object that may contain non-standard information.
			Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
		} `json:"asset,omitempty"`

		// Fix Fix for this finding, it comes expanded with all data preloaded
		Fix *struct {
			Data *struct {
				// Attributes Inlined attributes included in the relationship, if it is expanded.
				//
				// Expansion is a Snyk variation on JSON API. See
				// https://snyk.roadie.so/docs/default/component/sweater-comb/standards/rest/#expansion
				Attributes *FixAttributes     `json:"attributes,omitempty"`
				Id         openapi_types.UUID `json:"id"`
				Type       string             `json:"type"`
			} `json:"data,omitempty"`
		} `json:"fix,omitempty"`

		// Org Snyk organization scope in which the finding was discovered.
		Org *struct {
			Data *struct {
				Id   openapi_types.UUID `json:"id"`
				Type string             `json:"type"`
			} `json:"data,omitempty"`
		} `json:"org,omitempty"`

		// Policy Relate to the policy or policies applied to this finding.
		Policy *struct {
			Data *struct {
				// Attributes Inlined attributes included in the relationship, if it is expanded.
				//
				// Expansion is a Snyk variation on JSON API. See
				// https://snyk.roadie.so/docs/default/component/sweater-comb/standards/rest/#expansion
				Attributes *PolicyAttributes  `json:"attributes,omitempty"`
				Id         openapi_types.UUID `json:"id"`
				Type       string             `json:"type"`
			} `json:"data,omitempty"`
			Links IoSnykApiCommonRelatedLink `json:"links"`

			// Meta Free-form object that may contain non-standard information.
			Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
		} `json:"policy,omitempty"`

		// Test Test in which this finding was discovered.
		Test *struct {
			Data *struct {
				Id   openapi_types.UUID `json:"id"`
				Type string             `json:"type"`
			} `json:"data,omitempty"`
			Links IoSnykApiCommonRelatedLink `json:"links"`

			// Meta Free-form object that may contain non-standard information.
			Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
		} `json:"test,omitempty"`
	} `json:"relationships,omitempty"`
	Type *FindingDataType `json:"type,omitempty"`
}

// FindingDataType defines model for FindingData.Type.
type FindingDataType string

// FindingLocation Location within an Subject's contents where the finding was discovered.
type FindingLocation struct {
	union json.RawMessage
}

// FindingSummary Summary of findings found by the Test.
type FindingSummary struct {
	// Count Total count of findings.
	Count uint32 `json:"count"`

	// CountBy Counts of findings grouped by various finding attributes.
	//
	// The outer record is keyed by finding attribute name. The value is a record
	// keyed by distinct values of this attribute, whose value is the number of
	// findings with a distinct value.
	CountBy *map[string]map[string]uint32 `json:"count_by,omitempty"`
}

// FindingType Type of Finding which was discovered.
type FindingType string

// FixAppliedOutcome Indicates the outcome of a fix in terms of resolving the finding at hand
type FixAppliedOutcome string

// FixAttributes FixAttributes is the main payload modelling a fix
type FixAttributes struct {
	// Actions Different types of managed OS package fix actions
	Actions *Action `json:"actions,omitempty"`

	// Outcome Indicates whether applying these actions will address the finding or not
	Outcome FixAppliedOutcome `json:"outcome"`
}

// GitUrlCoordinatesSubject Test subject representing a source tree located in a Git repository that
// has a Snyk SCM integration.
type GitUrlCoordinatesSubject struct {
	// CommitId Commit ID of the Git commit from which content will be retrieved for the
	// test.
	CommitId string `json:"commit_id"`

	// IntegrationId Integration used to access the Git SCM repository in order to retrieve its source contents.
	IntegrationId openapi_types.UUID `json:"integration_id"`

	// Locator Locate the SCM repository from which content will be retrieved for the
	// test.
	Locator ScmRepoLocator               `json:"locator"`
	Type    GitUrlCoordinatesSubjectType `json:"type"`
}

// GitUrlCoordinatesSubjectType defines model for GitUrlCoordinatesSubject.Type.
type GitUrlCoordinatesSubjectType string

// GithubSecurityAdvisoryProblem Github Security Advisory associated with this finding.
type GithubSecurityAdvisoryProblem struct {
	Id     string                              `json:"id"`
	Source GithubSecurityAdvisoryProblemSource `json:"source"`
}

// GithubSecurityAdvisoryProblemSource defines model for GithubSecurityAdvisoryProblem.Source.
type GithubSecurityAdvisoryProblemSource string

// Ignore defines model for Ignore.
type Ignore struct {
	ActionType IgnoreActionType `json:"action_type"`
	Ignore     IgnoreDetails    `json:"ignore"`

	// PolicyRef Reference to a policy, serving as a container for a set of policy-rules and can be owned by the group or the org.
	PolicyRef *SnykPolicyRef `json:"policy_ref,omitempty"`

	// Rule A policy rule is the central entity of a policy, including an action as well as conditions
	// when this policy applies.
	// Only a subset of fields are included, for more details see the API documentation
	// https://apidocs.snyk.io/?version=2024-10-15#get-/orgs/-org_id-/policies/-policy_id-
	Rule *PolicyRule `json:"rule,omitempty"`
}

// IgnoreActionType defines model for Ignore.ActionType.
type IgnoreActionType string

// IgnoreDetails defines model for IgnoreDetails.
type IgnoreDetails struct {
	Created *time.Time `json:"created,omitempty"`

	// DisregardIfFixable Disregards the policy if set to true and the finding this policy is applied to is fixable
	DisregardIfFixable *bool                    `json:"disregard_if_fixable,omitempty"`
	Expires            *time.Time               `json:"expires,omitempty"`
	IgnoredBy          *IgnoredBy               `json:"ignored_by,omitempty"`
	Path               *[]string                `json:"path,omitempty"`
	Reason             string                   `json:"reason"`
	ReasonType         *IgnoreDetailsReasonType `json:"reason_type,omitempty"`
	Source             string                   `json:"source"`
}

// IgnoreDetailsReasonType defines model for IgnoreDetails.ReasonType.
type IgnoreDetailsReasonType string

// IgnoredBy defines model for IgnoredBy.
type IgnoredBy struct {
	// Email Email of the user who created the ignore
	Email *string `json:"email,omitempty"`

	// Id User ID of the author of the ignore
	Id openapi_types.UUID `json:"id"`

	// Name Name of the user who created the ignore
	Name string `json:"name"`
}

// JobAttributes JobAttributes represents the attributes of a Job resource
type JobAttributes struct {
	// CreatedAt Creation time of the job resource
	CreatedAt time.Time `json:"created_at"`

	// Status State of the test, whether it is pending, running, complete or errored.
	Status TestExecutionStates `json:"status"`
}

// JobData JobData represents a Job resource object.
type JobData struct {
	// Attributes JobAttributes represents the attributes of a Job resource
	Attributes    JobAttributes      `json:"attributes"`
	Id            openapi_types.UUID `json:"id"`
	Relationships *JobRelationships  `json:"relationships,omitempty"`
	Type          JobDataType        `json:"type"`
}

// JobDataType defines model for JobData.Type.
type JobDataType string

// JobRelationshipField defines model for JobRelationshipField.
type JobRelationshipField struct {
	Data struct {
		Id   openapi_types.UUID           `json:"id"`
		Type JobRelationshipFieldDataType `json:"type"`
	} `json:"data"`
}

// JobRelationshipFieldDataType defines model for JobRelationshipField.Data.Type.
type JobRelationshipFieldDataType string

// JobRelationships defines model for JobRelationships.
type JobRelationships struct {
	Test JobRelationshipField `json:"test"`
}

// JsonApi defines model for JsonApi.
type JsonApi struct {
	// Version Version of the JSON API specification this server supports.
	Version string `json:"version"`
}

// LinkProperty defines model for LinkProperty.
type LinkProperty struct {
	union json.RawMessage
}

// LinkProperty0 A string containing the link’s URL.
type LinkProperty0 = string

// LinkProperty1 defines model for .
type LinkProperty1 struct {
	// Href A string containing the link’s URL.
	Href string `json:"href"`

	// Meta Free-form object that may contain non-standard information.
	Meta *Meta `json:"meta,omitempty"`
}

// LocalIgnore defines model for LocalIgnore.
type LocalIgnore struct {
	// CreatedAt When the ignore was first created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// ExpiresAt When the ignore will expire.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Path Dependency path to the vulnerable package to be ignored.
	//
	// If not provided, the ignore will apply to all packages with the given
	// vulnerability ID.
	Path *[]string `json:"path,omitempty"`

	// Reason Reason for the ignore.
	Reason *string `json:"reason,omitempty"`

	// SkipIfFixable Skips the ignore rule if an actual fix is available.
	SkipIfFixable *bool `json:"skip_if_fixable,omitempty"`

	// VulnId The vulnerability ID of the finding to be ignored.
	//
	// This typically matches SnykVulnProblem.id for open source vulnerabilities.
	VulnId string `json:"vuln_id"`
}

// LocalPathLocator LocalPathLocator locates a test subject by local file paths, relative to the
// working copy top-level directory of the source code.
type LocalPathLocator struct {
	// Paths Local file paths.
	Paths []string             `json:"paths"`
	Type  LocalPathLocatorType `json:"type"`
}

// LocalPathLocatorType defines model for LocalPathLocator.Type.
type LocalPathLocatorType string

// LocalPolicy Locally configured policy options for determining outcome of this specific test.
type LocalPolicy struct {
	// FailOnUpgradable Use to fail a test when there is at least one vulnerable finding that can be fixed by upgrading the version of the related
	//    dependency. E.g. bumping lodash from 1.1.1 to 1.1.2.
	FailOnUpgradable *bool `json:"fail_on_upgradable,omitempty"`

	// Ignores Defines ignore rules for known issues.
	Ignores *[]LocalIgnore `json:"ignores,omitempty"`

	// ReachabilityFilter Represent various reachability filters available for findings.
	ReachabilityFilter *ReachabilityFilter `json:"reachability_filter,omitempty"`

	// RiskScoreThreshold Findings of equal or greater risk score will fail the test.
	RiskScoreThreshold *uint16 `json:"risk_score_threshold,omitempty"`

	// SeverityThreshold Findings of equal or greater severity will fail the test.
	SeverityThreshold *Severity `json:"severity_threshold,omitempty"`

	// SuppressPendingIgnores Suppress ignores pending approval, so that they do not fail the test. If
	// allowed by administrators, this might be set in developer workflows in
	// order to unblock local development while an ignore is pending approval.
	SuppressPendingIgnores bool `json:"suppress_pending_ignores"`
}

// ManagedPolicyRef Reference to a managed policy.
type ManagedPolicyRef struct {
	Id Uuid `json:"id"`
}

// Meta Free-form object that may contain non-standard information.
type Meta map[string]interface{}

// OtherEvidence Evidence which this API version is not capable of expressing.
//
// More information may be available in a newer version of this API.
type OtherEvidence struct {
	Source OtherEvidenceSource `json:"source"`
}

// OtherEvidenceSource defines model for OtherEvidence.Source.
type OtherEvidenceSource string

// OtherLocation Finding locations which this API version is not capable of expressing.
//
// This location may be available in a newer version of this API.
type OtherLocation struct {
	Type OtherLocationType `json:"type"`
}

// OtherLocationType defines model for OtherLocation.Type.
type OtherLocationType string

// OtherLocator OtherLocator represents any locator that this version of the API is not
// capable of expressing.
type OtherLocator struct {
	Type OtherLocatorType `json:"type"`
}

// OtherLocatorType defines model for OtherLocator.Type.
type OtherLocatorType string

// OtherProblem Problem which this API version is not capable of expressing.
//
// This problem may be available in a newer version of this API.
type OtherProblem struct {
	Source OtherProblemSource `json:"source"`
}

// OtherProblemSource defines model for OtherProblem.Source.
type OtherProblemSource string

// OtherSubject OtherSubject represents any subject that this version of the API is not
// capable of expressing.
type OtherSubject struct {
	Type OtherSubjectType `json:"type"`
}

// OtherSubjectType defines model for OtherSubject.Type.
type OtherSubjectType string

// Package Dependency models a package dependency.
type Package struct {
	// Name Name is the name of the package.
	Name string `json:"name"`

	// Version Version is the version of the named package.
	Version string `json:"version"`
}

// PackageLocation Package dependency version.
//
// Finding type: SCA
type PackageLocation struct {
	// Package Dependency models a package dependency.
	Package Package             `json:"package"`
	Type    PackageLocationType `json:"type"`
}

// PackageLocationType defines model for PackageLocation.Type.
type PackageLocationType string

// PassFail Indicate whether a Test passes or fails.
type PassFail string

// PinPackageAction Pin a package at a specific version. Pinning is a capability not supported
// by all ecosystems, which causes a transitive dependency to be pinned at
// a specific version with an override.
//
// For example, the `replace` go.mod directive can override package dependency
// constraints, forcing a specific version to be used in the application.
//
// Pinning could break an application.
//
// Note: In practice pin actions today are solely used in python pip's packages as pip does not calculate upgrade paths
type PinPackageAction struct {
	PackageName string               `json:"package_name"`
	PinVersion  string               `json:"pin_version"`
	Type        PinPackageActionType `json:"type"`
}

// PinPackageActionType defines model for PinPackageAction.Type.
type PinPackageActionType string

// Policy defines model for Policy.
type Policy struct {
	AppliedPolicy AppliedPolicy      `json:"applied_policy"`
	Id            openapi_types.UUID `json:"id"`
	Type          PolicyType         `json:"type"`
}

// PolicyType defines model for Policy.Type.
type PolicyType string

// PolicyAttributes defines model for PolicyAttributes.
type PolicyAttributes struct {
	Policies []Policy `json:"policies"`
}

// PolicyModification Prior attribute values and the reason they were modified.
type PolicyModification struct {
	// Pointer A JSON Pointer (RFC 6901) reference to the modified value, relative to
	// the top-level attributes of the same Finding.
	Pointer string `json:"pointer"`

	// Policy Policy which modified the finding, if available.
	Policy *PolicyRef `json:"policy,omitempty"`

	// Prior The prior value at the referenced pointer.
	Prior *interface{} `json:"prior,omitempty"`

	// Reason A human-readable explanation for why the value was modified.
	Reason string `json:"reason"`
}

// PolicyRef Reference to a single policy.
type PolicyRef struct {
	union json.RawMessage
}

// PolicyRef0 defines model for PolicyRef.0.
type PolicyRef0 string

// PolicyRefSet A set of local and/or managed policies.
type PolicyRefSet struct {
	Ids         []Uuid `json:"ids"`
	LocalPolicy *bool  `json:"local_policy,omitempty"`
}

// PolicyRule A policy rule is the central entity of a policy, including an action as well as conditions
// when this policy applies.
// Only a subset of fields are included, for more details see the API documentation
// https://apidocs.snyk.io/?version=2024-10-15#get-/orgs/-org_id-/policies/-policy_id-
type PolicyRule struct {
	Created  time.Time          `json:"created"`
	Id       openapi_types.UUID `json:"id"`
	Modified time.Time          `json:"modified"`
	Name     string             `json:"name"`
	Review   PolicyRuleReview   `json:"review"`
}

// PolicyRuleReview defines model for PolicyRule.Review.
type PolicyRuleReview string

// Problem Problems are representative of the finding in other security domains and
// systems with a well-known identifier.
//
// More detailed attributes for the problem may be included, especially when
// this information is not yet readily available in a relatable public API.
//
// Problems are defined in industry standard taxonomies such as:
// - MITRE's Common Weakness Enumeration (CWE)
// - Common Vulnerability Exposures (CVE)
//
// Snyk systems also define problems, such as:
// - Code SAST rules
// - VulnDB vulnerabilities
// - Software licenses
type Problem struct {
	union json.RawMessage
}

// ProjectEntityLocator ProjectEntityLocator locates a Snyk Project by its public ID.
type ProjectEntityLocator struct {
	// ProjectId Public ID of the Snyk Project.
	ProjectId openapi_types.UUID       `json:"project_id"`
	Type      ProjectEntityLocatorType `json:"type"`
}

// ProjectEntityLocatorType defines model for ProjectEntityLocator.Type.
type ProjectEntityLocatorType string

// ProjectNameLocator ProjectNameLocator locates a Snyk Project by its name.
type ProjectNameLocator struct {
	// ProjectName Name of the Snyk Project.
	ProjectName string `json:"project_name"`

	// TargetReference Target reference which differentiates this project, for example, with a
	// branch name or version. Projects having the same reference can be grouped
	// based on that reference.
	TargetReference *string                `json:"target_reference,omitempty"`
	Type            ProjectNameLocatorType `json:"type"`
}

// ProjectNameLocatorType defines model for ProjectNameLocator.Type.
type ProjectNameLocatorType string

// QueryVersion Requested API version
type QueryVersion = string

// Rating Rating represents qualitative metrics on a finding.
type Rating struct {
	// Severity Severity level of the finding.
	Severity Severity `json:"severity"`
}

// ReachabilityEvidence Indicate the reachability signals as additional evidence for the finding.
type ReachabilityEvidence struct {
	// Paths Sequence of locations within this flow of execution.
	//
	// For example, a sequence of locations connecting the "source" location
	// where input data is obtained, to a "sink" location where it is used.
	Paths *[]ReachablePath `json:"paths,omitempty"`

	// Reachability Reachability enum for reachability signal.
	Reachability ReachabilityType           `json:"reachability"`
	Source       ReachabilityEvidenceSource `json:"source"`
}

// ReachabilityEvidenceSource defines model for ReachabilityEvidence.Source.
type ReachabilityEvidenceSource string

// ReachabilityFilter Represent various reachability filters available for findings.
type ReachabilityFilter string

// ReachabilityType Reachability enum for reachability signal.
type ReachabilityType string

// ReachablePath ReachablePath represents the paths to a vulnerable function.
type ReachablePath struct {
	// CallPaths Paths in code bundle that call the vulnerable function.
	CallPaths []string `json:"call_paths"`

	// FunctionName Vulnerable function name.
	FunctionName string `json:"function_name"`

	// Location Location in a file where the vulnerability can be found.
	Location *FileRegion `json:"location,omitempty"`
}

// Risk Risk represents Snyk's risk assessment of a finding.
type Risk struct {
	// RiskScore Risk score assessment for the finding.
	RiskScore *RiskScore `json:"risk_score,omitempty"`
}

// RiskScore Risk score assigns a numeric metric based on various attributes of the
// finding and the risk context in which it was discovered.
type RiskScore struct {
	Value uint16 `json:"value"`
}

// SbomReachabilitySubject Test subject for SBOM test with reachability analysis.
type SbomReachabilitySubject struct {
	// CodeBundleId Source code to inspect for the reach of the vulnerable dependencies.
	CodeBundleId string `json:"code_bundle_id"`

	// Locator Locate the local paths from which the SBOM and source code were derived.
	Locator LocalPathLocator `json:"locator"`

	// SbomBundleId The SBOM to test for vulnerable dependencies.
	SbomBundleId string                      `json:"sbom_bundle_id"`
	Type         SbomReachabilitySubjectType `json:"type"`
}

// SbomReachabilitySubjectType defines model for SbomReachabilitySubject.Type.
type SbomReachabilitySubjectType string

// SbomSubject Test subject for SBOM test without reachability analysis.
type SbomSubject struct {
	// Locator Locate the local paths from which the SBOM and source code were derived.
	Locator LocalPathLocator `json:"locator"`

	// SbomBundleId The SBOM to test for vulnerable dependencies.
	SbomBundleId string          `json:"sbom_bundle_id"`
	Type         SbomSubjectType `json:"type"`
}

// SbomSubjectType defines model for SbomSubject.Type.
type SbomSubjectType string

// ScmRepoLocator ScmRepoLocator locates a test subject by SCM repository coordinates.
type ScmRepoLocator struct {
	// BranchName Branch name, if known and applicable to locating the test subject.
	//
	// If not specified, the branch name can be assumed to be the "default
	// integration branch" of the repository.
	BranchName *string            `json:"branch_name,omitempty"`
	Type       ScmRepoLocatorType `json:"type"`

	// Url URL of the SCM repository.
	Url string `json:"url"`
}

// ScmRepoLocatorType defines model for ScmRepoLocator.Type.
type ScmRepoLocatorType string

// Severity Indicate the severity of a finding discovered by a Test.
type Severity string

// SeverityChange defines model for SeverityChange.
type SeverityChange struct {
	ActionType SeverityChangeActionType `json:"action_type"`

	// PolicyRef Reference to a policy, serving as a container for a set of policy-rules and can be owned by the group or the org.
	PolicyRef SnykPolicyRef `json:"policy_ref"`

	// Rule A policy rule is the central entity of a policy, including an action as well as conditions
	// when this policy applies.
	// Only a subset of fields are included, for more details see the API documentation
	// https://apidocs.snyk.io/?version=2024-10-15#get-/orgs/-org_id-/policies/-policy_id-
	Rule           PolicyRule            `json:"rule"`
	SeverityChange SeverityChangeDetails `json:"severity_change"`
}

// SeverityChangeActionType defines model for SeverityChange.ActionType.
type SeverityChangeActionType string

// SeverityChangeDetails defines model for SeverityChangeDetails.
type SeverityChangeDetails struct {
	// NewSeverity Indicate the severity of a finding discovered by a Test.
	NewSeverity Severity `json:"new_severity"`

	// OriginalSeverity Indicate the severity of a finding discovered by a Test.
	OriginalSeverity Severity `json:"original_severity"`
}

// SnykCloudRuleProblem Configuration policy violation from Snyk's Cloud Rules Database.
type SnykCloudRuleProblem struct {
	Id     string                     `json:"id"`
	Source SnykCloudRuleProblemSource `json:"source"`
}

// SnykCloudRuleProblemSource defines model for SnykCloudRuleProblem.Source.
type SnykCloudRuleProblemSource string

// SnykCodeRuleProblem Static code analysis rule, from the standard Snyk Code rule set.
type SnykCodeRuleProblem struct {
	// DefaultConfiguration Snyk Code rule configuration options.
	DefaultConfiguration SnykcoderuleConfiguration `json:"default_configuration"`

	// Help Represent a message string in multiple formats: plain text or markdown.
	Help SnykcoderuleMultiformatMessageString `json:"help"`
	Id   string                               `json:"id"`
	Name string                               `json:"name"`

	// Properties Additional properties of a Snyk Code rule. Represented in SARIF as free-form
	// metadata, but Snyk Code scanner outputs prescribe a specific structure for
	// this content.
	Properties SnykcoderuleProperties `json:"properties"`

	// ShortDescription Represent a message string in multiple formats: plain text or markdown.
	ShortDescription SnykcoderuleMultiformatMessageString `json:"short_description"`
	Source           SnykCodeRuleProblemSource            `json:"source"`
}

// SnykCodeRuleProblemSource defines model for SnykCodeRuleProblem.Source.
type SnykCodeRuleProblemSource string

// SnykLicenseProblem License from Snyk's Vulnerability Database.
//
// A software license can be considered a problem when policy designates it as
// a business risk.
type SnykLicenseProblem struct {
	// AffectedHashRanges Range of commit hashes known to be affected by this problem.
	//
	// Generally used with package ecosystems which use Git SCM repositories for
	// distribution.
	AffectedHashRanges *[]string `json:"affected_hash_ranges,omitempty"`

	// AffectedHashes List of specific commit hashes known to be affected by this problem.
	AffectedHashes *[]string `json:"affected_hashes,omitempty"`

	// AffectedVersions All the package versions which are affected by this problem. Expect this to
	// be smaller than 0 ([,0] or <0.0.0 ) for vulnerabilities that have been
	// revoked. Per ecosystem, the official package version guidelines are
	// being used.
	AffectedVersions *[]string `json:"affected_versions,omitempty"`

	// CreatedAt Timestamp indicating when the problem was orginally created.
	CreatedAt time.Time `json:"created_at"`

	// Ecosystem Package ecosystem in which the package is distributed.
	//
	// This applies to private packages distributed with ecosystem tooling as well
	// as those publicly distributed.
	Ecosystem SnykvulndbPackageEcosystem `json:"ecosystem"`
	Id        string                     `json:"id"`

	// Instructions License policy instructions. Legal instructions for the user on what to do
	// when met with the license policy violation.
	Instructions []SnykvulndbLicenseInstructions `json:"instructions"`

	// License Software license identifier.
	License string `json:"license"`

	// PackageName Package name.
	PackageName string `json:"package_name"`

	// PackageVersion Package version.
	PackageVersion string `json:"package_version"`

	// PublishedAt Timestamp indicating when the problem was published.
	PublishedAt time.Time `json:"published_at"`

	// Severity The Snyk curated or recommended vulnerability severity for the problem.
	Severity Severity                 `json:"severity"`
	Source   SnykLicenseProblemSource `json:"source"`
}

// SnykLicenseProblemSource defines model for SnykLicenseProblem.Source.
type SnykLicenseProblemSource string

// SnykPolicyRef Reference to a policy, serving as a container for a set of policy-rules and can be owned by the group or the org.
type SnykPolicyRef struct {
	Id    openapi_types.UUID `json:"id"`
	Owner SnykPolicyRefOwner `json:"owner"`
}

// SnykPolicyRefOwner defines model for SnykPolicyRef.Owner.
type SnykPolicyRefOwner string

// SnykVulnProblem Vulnerability from Snyk's Vulnerability Database.
type SnykVulnProblem struct {
	// AffectedHashRanges Range of commit hashes known to be affected by this problem.
	//
	// Generally used with package ecosystems which use Git SCM repositories for
	// distribution.
	AffectedHashRanges *[]string `json:"affected_hash_ranges,omitempty"`

	// AffectedHashes List of specific commit hashes known to be affected by this problem.
	AffectedHashes *[]string `json:"affected_hashes,omitempty"`

	// AffectedVersions All the package versions which are affected by this problem. Expect this to
	// be smaller than 0 ([,0] or <0.0.0 ) for vulnerabilities that have been
	// revoked. Per ecosystem, the official package version guidelines are
	// being used.
	AffectedVersions *[]string `json:"affected_versions,omitempty"`

	// CreatedAt Timestamp indicating when the problem was orginally created.
	CreatedAt time.Time `json:"created_at"`

	// Credits Discoverer / Reporter of the vulnerability.
	Credits []string `json:"credits"`

	// CvssBaseScore The Snyk curated or recommended CVSS score, in the highest CVSS version
	// supported and available for the issue, computed based on the Base Score
	// of the cvss_vector field.
	CvssBaseScore SnykvulndbCvssScore `json:"cvss_base_score"`

	// CvssSources All CVSS vector information (Base), with corresponding sources, scores
	// and severities applying to the same vulnerability. The data is sourced
	// from external security vendors (e.g. NVD), as well as assigned by Snyk.
	//
	// The “type” key indicates whether this is the “primary” (recommended) CVSS
	// to use, or “secondary” (provided as additional information).
	//
	// Information might be partial and will be updated upon evaluation by
	// external sources.
	CvssSources []SnykvulndbCvssSource `json:"cvss_sources"`

	// CvssVector The primary CVSS Base vector, either Snyk curated or from the recommended
	// source, in v3.0, v3.1 or v4.0 CVSS versions. Might include exploit
	// values where applicable.
	CvssVector string `json:"cvss_vector"`

	// DisclosedAt Timestamp of when the vulnerability was first made publicly available
	// (either known to us or as appears in the vulnerability source)
	DisclosedAt time.Time `json:"disclosed_at"`

	// Ecosystem Package ecosystem in which the package is distributed.
	//
	// This applies to private packages distributed with ecosystem tooling as well
	// as those publicly distributed.
	Ecosystem SnykvulndbPackageEcosystem `json:"ecosystem"`

	// EpssDetails EPSS details - see note on model definition.
	EpssDetails *SnykvulndbEpssDetails `json:"epss_details,omitempty"`

	// ExploitDetails Details about the maturity of exploits for this vulnerability.
	ExploitDetails SnykvulndbExploitDetails `json:"exploit_details"`
	Id             string                   `json:"id"`

	// InitiallyFixedInVersions This indicates the earliest version that is vulnerability-free. As this
	// might be a backported fix, this does not mean that newer versions aren’t
	// vulnerable. vulnerable_versions should also be used to determine whether
	// a given version is vulnerable.
	InitiallyFixedInVersions []string `json:"initially_fixed_in_versions"`

	// IsFixable Is there a fixed version published to the relevant package manager
	// repository- i.e., a newer version without this specific vulnerability
	IsFixable bool `json:"is_fixable"`

	// IsMalicious Indicate if the vulnerability is known to mark a malicious package.
	IsMalicious bool `json:"is_malicious"`

	// IsSocialMediaTrending This boolean field is true when increased activity is detected related to
	// this vulnerability. The "trending" determination is based on social media
	// activity, using Snyk models which are tuned to detect an increased chance
	// of near-future exploitation.
	IsSocialMediaTrending bool `json:"is_social_media_trending"`

	// ModifiedAt Timestamp indicating when the vulnerability was last modified (anything
	// from typo to version change). When the vulnerability is first added, this
	// field and published will be (almost) identical.
	ModifiedAt time.Time `json:"modified_at"`

	// PackageName Package name.
	PackageName string `json:"package_name"`

	// PackagePopularityRank Percentile rank indicating the package's prevalence across Snyk-monitored projects.
	// A higher rank signifies the package is used in a larger percentage of projects.
	PackagePopularityRank *float32 `json:"package_popularity_rank,omitempty"`

	// PackageRepositoryUrl Link to the package repository containing the vulnerable package.
	PackageRepositoryUrl *string `json:"package_repository_url,omitempty"`

	// PackageVersion Package version.
	PackageVersion string `json:"package_version"`

	// PublishedAt Timestamp indicating when the problem was published.
	PublishedAt time.Time `json:"published_at"`

	// References Links to external websites related to the vulnerability. Links also
	// include a user-facing curated title.
	References []SnykvulndbReferenceLinks `json:"references"`

	// Severity The Snyk curated or recommended vulnerability severity for the problem.
	Severity Severity              `json:"severity"`
	Source   SnykVulnProblemSource `json:"source"`

	// VendorSeverity The assigned severity/impact/urgency rating by the distros teams for the
	// specific vulnerability package and release of the operating system (if available).
	VendorSeverity *string `json:"vendor_severity,omitempty"`

	// VulnerableFunctions Known vulnerable functions in software packages.
	VulnerableFunctions *map[string]SnykvulndbVulnerableFunction `json:"vulnerable_functions,omitempty"`
}

// SnykVulnProblemSource defines model for SnykVulnProblem.Source.
type SnykVulnProblemSource string

// SourceLocation Source file location.
//
// Finding types: SCA, SAST
type SourceLocation struct {
	// FilePath File path for the code snippet.
	FilePath string `json:"file_path"`

	// FromColumn Column on which the snippet starts.
	FromColumn *int `json:"from_column,omitempty"`

	// FromLine Line in the file where the code snippet starts.
	FromLine int `json:"from_line"`

	// ToColumn Column at which the code snippet ends.
	ToColumn *int `json:"to_column,omitempty"`

	// ToLine Line on which the code snippet ends.
	ToLine *int               `json:"to_line,omitempty"`
	Type   SourceLocationType `json:"type"`
}

// SourceLocationType defines model for SourceLocation.Type.
type SourceLocationType string

// Suppression Details about a finding's suppression in test results.
//
// Suppressed findings do not contribute to the test outcome, but they are still
// provided in the results.
type Suppression struct {
	// CreatedAt When the suppression was first created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// ExpiresAt When the suppression will expire.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Justification Reason given for an ignore pending approval.
	Justification *string `json:"justification,omitempty"`

	// Path Dependency path to the vulnerable package to be suppressed.
	//
	// If not provided, the suppression will apply to all packages with the given
	// vulnerability ID.
	Path *[]string `json:"path,omitempty"`

	// Policy Policy responsible for the state of suppression represented here, if available.
	Policy *PolicyRef `json:"policy,omitempty"`

	// SkipIfFixable Skip the suppression if an actual fix is available.
	SkipIfFixable *bool `json:"skipIfFixable,omitempty"`

	// Status Status of the suppression.
	Status SuppressionStatus `json:"status"`
}

// SuppressionStatus Status of a suppression on a finding.
type SuppressionStatus string

// TestAttributes TestAttributes represents the attributes of a Test resource.
type TestAttributes struct {
	// Config The test configuration. If not specified, caller accepts test configuration
	// defaults within the calling scope (org, group or tenant settings, etc).
	Config *TestConfiguration `json:"config,omitempty"`

	// CreatedAt Creation time of the test resource.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// EffectiveSummary Summary of findings discovered by the test, effective to the outcome
	// decision. This summary excludes findings suppressed by policy.
	//
	// This attribute is set when the test execution
	// completes (state.execution == 'finished') successfully (without fatal errors
	// blocking an outcome).
	EffectiveSummary *FindingSummary `json:"effective_summary,omitempty"`

	// Outcome The outcome of the test.
	//
	// This attribute is set when the test execution
	// completes (state.execution == 'completed') successfully (without fatal errors
	// blocking an outcome).
	Outcome *TestOutcome `json:"outcome,omitempty"`

	// RawSummary Summary of findings regardless of whether they are effective or not. This
	// summary includes all findings, even those suppressed by policy.
	//
	// This attribute is set when the test execution
	// completes (state.execution == 'finished') successfully (without fatal errors
	// blocking an outcome).
	RawSummary *FindingSummary `json:"raw_summary,omitempty"`

	// State The state of the test's execution.
	State *TestState `json:"state,omitempty"`

	// Subject The subject of a test.
	Subject TestSubject `json:"subject"`

	// SubjectLocators Additional locators which may help locate the test subject across test workflows.
	//
	// Test subjects generally will have a primary locator. Additional locators
	// may be provided to help link the test to existing projects and/or assets in
	// the Snyk platform.
	SubjectLocators *[]TestSubjectLocator `json:"subject_locators,omitempty"`
}

// TestAttributesCreate TestAttributes represents the attributes of a Test resource.
type TestAttributesCreate struct {
	// Config The test configuration. If not specified, caller accepts test configuration
	// defaults within the calling scope (org, group or tenant settings, etc).
	Config *TestConfiguration `json:"config,omitempty"`

	// Subject The subject of a test.
	Subject TestSubjectCreate `json:"subject"`

	// SubjectLocators Additional locators which may help locate the test subject across test workflows.
	//
	// Test subjects generally will have a primary locator. Additional locators
	// may be provided to help link the test to existing projects and/or assets in
	// the Snyk platform.
	SubjectLocators *[]TestSubjectLocator `json:"subject_locators,omitempty"`
}

// TestConfiguration Test configuration.
type TestConfiguration struct {
	// LocalPolicy Inline configured policy options for determining outcome of this specific test.
	//
	// If centrally managed policies are in scope, inline policies are overridden
	// by managed policies. Policy references explain which policies were
	// effective for test evaluation.
	LocalPolicy *LocalPolicy `json:"local_policy,omitempty"`

	// PublishReport Publish findings into a report, viewable in the Snyk web UI.
	PublishReport *bool `json:"publish_report,omitempty"`

	// Timeout Maximum test time in seconds, after which execution will be cancelled and
	// the test will fail with reason "timeout".
	Timeout *TimeoutSpec `json:"timeout,omitempty"`
}

// TestData TestData represents a Test resource object.
type TestData struct {
	// Attributes TestAttributes represents the attributes of a Test resource.
	Attributes TestAttributes      `json:"attributes"`
	Id         *openapi_types.UUID `json:"id,omitempty"`
	Links      *struct {
		// Findings Link to the findings discovered by the test, when it completes.
		Findings *IoSnykApiCommonLinkProperty `json:"findings,omitempty"`
	} `json:"links,omitempty"`
	Type TestDataType `json:"type"`
}

// TestDataType defines model for TestData.Type.
type TestDataType string

// TestDataCreate TestData represents a Test resource object.
type TestDataCreate struct {
	// Attributes TestAttributes represents the attributes of a Test resource.
	Attributes TestAttributesCreate `json:"attributes"`
	Type       TestDataCreateType   `json:"type"`
}

// TestDataCreateType defines model for TestDataCreate.Type.
type TestDataCreateType string

// TestExecutionStates defines model for TestExecutionStates.
type TestExecutionStates string

// TestOutcome Outcome of a test; pass or fail.
type TestOutcome struct {
	// BreachedPolicies Test-level policies which were breached in a failing outcome.
	//
	// This array may be truncated for a large number of policies.
	BreachedPolicies *PolicyRefSet `json:"breached_policies,omitempty"`

	// Reason Reason for the outcome, if applicable.
	Reason *TestOutcomeReason `json:"reason,omitempty"`

	// Result Whether the test passed or failed.
	Result PassFail `json:"result"`
}

// TestOutcomeReason Reasons for the outcome.
type TestOutcomeReason string

// TestRequestBody TestRequestBody represents the request body used when creating an Test.
type TestRequestBody struct {
	// Data TestData represents a Test resource object.
	Data TestDataCreate `json:"data"`
}

// TestState Test execution state information.
type TestState struct {
	// Errors Errors which occurred during the execution of a test.
	//
	// If execution state is errored, at least one error will be
	// indicated here.
	Errors *[]IoSnykApiCommonError `json:"errors,omitempty"`

	// Execution Current execution state of the test. This should be polled to completion
	// ("completed" or "errored") when waiting for a test result.
	//
	// Completion is no guarantee of an outcome in the event of fatal errors.
	Execution TestExecutionStates `json:"execution"`

	// Warnings Non-fatal errors which occurred during the execution of a test.
	//
	// Execution state and warnings are not linked; any of passed/failed/
	// errored tests can have warnings.
	Warnings *[]IoSnykApiCommonError `json:"warnings,omitempty"`
}

// TestSubject The subject of a test, which identifies the asset/project and content references
// necessary to conduct a security test.
type TestSubject struct {
	union json.RawMessage
}

// TestSubjectCreate The subject of a test, which identifies the asset/project and content references
// necessary to conduct a security test.
type TestSubjectCreate struct {
	union json.RawMessage
}

// TestSubjectLocator defines model for TestSubjectLocator.
type TestSubjectLocator struct {
	union json.RawMessage
}

// TimeoutSpec Specification for a test timeout policy. If the test does not complete within
// the seconds specified, the test will instantly complete with the given outcome.
type TimeoutSpec struct {
	// Outcome Indicate whether a Test passes or fails.
	Outcome PassFail `json:"outcome"`
	Seconds uint32   `json:"seconds"`
}

// UpgradePackageAction Upgrade a package from one version to another.
type UpgradePackageAction struct {
	// PackageName The package that's receiving an upgrade to fix this vulnerability
	PackageName string                   `json:"package_name"`
	Type        UpgradePackageActionType `json:"type"`

	// UpgradePaths Upgrading a package may lead to one or more paths to change. These paths are modelled as evidence
	// in DependencyPathEvidence.
	//
	// Ultimately upgradePaths illustrates the minimum version upgrades that need to happen to apply this action.
	UpgradePaths []UpgradePath `json:"upgrade_paths"`
}

// UpgradePackageActionType defines model for UpgradePackageAction.Type.
type UpgradePackageActionType string

// UpgradePath Upgrade path model all known dependency paths that will change when applying an upgrade action.
type UpgradePath struct {
	DependencyPath []Package `json:"dependency_path"`

	// IsDrop A drop describes an upgrade path, where the vulnerability gets addressed by removing the vulnerable dependency.
	// This typically happens when a package somewhere mid-way drops this library in newer versions.
	//
	// Note: For drops, the length of the upgradePath will be smaller than the length of the original dependencyPath.
	IsDrop bool `json:"is_drop"`
}

// Uuid defines model for Uuid.
type Uuid = openapi_types.UUID

// IoSnykApiCommonError defines model for io.snyk.api.common.Error.
type IoSnykApiCommonError struct {
	// Code An application-specific error code, expressed as a string value.
	Code *string `json:"code,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Id A unique identifier for this particular occurrence of the problem.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Links A link that leads to further details about this particular occurrance of the problem.
	Links  *IoSnykApiCommonErrorLink `json:"links,omitempty"`
	Meta   *map[string]interface{}   `json:"meta,omitempty"`
	Source *struct {
		Parameter *string `json:"parameter,omitempty"`
		Pointer   *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `json:"title,omitempty"`
}

// IoSnykApiCommonErrorDocument defines model for io.snyk.api.common.ErrorDocument.
type IoSnykApiCommonErrorDocument struct {
	Errors  []IoSnykApiCommonError `json:"errors"`
	Jsonapi IoSnykApiCommonJsonApi `json:"jsonapi"`
}

// IoSnykApiCommonErrorLink A link that leads to further details about this particular occurrance of the problem.
type IoSnykApiCommonErrorLink struct {
	About                *IoSnykApiCommonLinkProperty           `json:"about,omitempty"`
	AdditionalProperties map[string]IoSnykApiCommonLinkProperty `json:"-"`
}

// IoSnykApiCommonJsonApi defines model for io.snyk.api.common.JsonApi.
type IoSnykApiCommonJsonApi struct {
	// Version Version of the JSON API specification this server supports.
	Version IoSnykApiCommonJsonApiVersion `json:"version"`
}

// IoSnykApiCommonJsonApiVersion Version of the JSON API specification this server supports.
type IoSnykApiCommonJsonApiVersion string

// IoSnykApiCommonLinkObject defines model for io.snyk.api.common.LinkObject.
type IoSnykApiCommonLinkObject struct {
	Href IoSnykApiCommonLinkString `json:"href"`

	// Meta Free-form object that may contain non-standard information.
	Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
}

// IoSnykApiCommonLinkProperty defines model for io.snyk.api.common.LinkProperty.
type IoSnykApiCommonLinkProperty struct {
	union json.RawMessage
}

// IoSnykApiCommonLinkString defines model for io.snyk.api.common.LinkString.
type IoSnykApiCommonLinkString = string

// IoSnykApiCommonMeta Free-form object that may contain non-standard information.
type IoSnykApiCommonMeta map[string]interface{}

// IoSnykApiCommonPaginatedLinks defines model for io.snyk.api.common.PaginatedLinks.
type IoSnykApiCommonPaginatedLinks struct {
	First *IoSnykApiCommonLinkProperty `json:"first,omitempty"`
	Last  *IoSnykApiCommonLinkProperty `json:"last,omitempty"`
	Next  *IoSnykApiCommonLinkProperty `json:"next,omitempty"`
	Prev  *IoSnykApiCommonLinkProperty `json:"prev,omitempty"`
	Self  *IoSnykApiCommonLinkProperty `json:"self,omitempty"`
}

// IoSnykApiCommonRelatedLink defines model for io.snyk.api.common.RelatedLink.
type IoSnykApiCommonRelatedLink struct {
	Related *IoSnykApiCommonLinkProperty `json:"related,omitempty"`
}

// IoSnykApiV1testdepgraphRequestDepGraph defines model for io.snyk.api.v1testdepgraph.request.DepGraph.
type IoSnykApiV1testdepgraphRequestDepGraph struct {
	Graph                IoSnykApiV1testdepgraphRequestGraph          `json:"graph"`
	PkgManager           IoSnykApiV1testdepgraphRequestPackageManager `json:"pkgManager"`
	Pkgs                 []IoSnykApiV1testdepgraphRequestPackage      `json:"pkgs"`
	SchemaVersion        string                                       `json:"schemaVersion"`
	AdditionalProperties map[string]interface{}                       `json:"-"`
}

// IoSnykApiV1testdepgraphRequestGraph defines model for io.snyk.api.v1testdepgraph.request.Graph.
type IoSnykApiV1testdepgraphRequestGraph struct {
	Nodes                []IoSnykApiV1testdepgraphRequestNode `json:"nodes"`
	RootNodeId           string                               `json:"rootNodeId"`
	AdditionalProperties map[string]interface{}               `json:"-"`
}

// IoSnykApiV1testdepgraphRequestNode defines model for io.snyk.api.v1testdepgraph.request.Node.
type IoSnykApiV1testdepgraphRequestNode struct {
	Deps                 []IoSnykApiV1testdepgraphRequestNodeRef `json:"deps"`
	NodeId               string                                  `json:"nodeId"`
	PkgId                string                                  `json:"pkgId"`
	AdditionalProperties map[string]interface{}                  `json:"-"`
}

// IoSnykApiV1testdepgraphRequestNodeRef defines model for io.snyk.api.v1testdepgraph.request.NodeRef.
type IoSnykApiV1testdepgraphRequestNodeRef struct {
	NodeId               string                 `json:"nodeId"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IoSnykApiV1testdepgraphRequestPackage defines model for io.snyk.api.v1testdepgraph.request.Package.
type IoSnykApiV1testdepgraphRequestPackage struct {
	Id                   string                                    `json:"id"`
	Info                 IoSnykApiV1testdepgraphRequestPackageInfo `json:"info"`
	AdditionalProperties map[string]interface{}                    `json:"-"`
}

// IoSnykApiV1testdepgraphRequestPackageInfo defines model for io.snyk.api.v1testdepgraph.request.PackageInfo.
type IoSnykApiV1testdepgraphRequestPackageInfo struct {
	Name                 string                 `json:"name"`
	Version              string                 `json:"version"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IoSnykApiV1testdepgraphRequestPackageManager defines model for io.snyk.api.v1testdepgraph.request.PackageManager.
type IoSnykApiV1testdepgraphRequestPackageManager struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SnykcoderuleConfiguration Snyk Code rule configuration options.
type SnykcoderuleConfiguration struct {
	// Severity Severity to apply when the rule matches.
	Severity Severity `json:"severity"`
}

// SnykcoderuleExampleCommitChange Source line content, line number, and unified diff indicating the changes in
// the fix.
type SnykcoderuleExampleCommitChange struct {
	Line       string `json:"line"`
	LineChange string `json:"line_change"`
	LineNumber uint32 `json:"line_number"`
}

// SnykcoderuleExampleCommitFix An example of fixing this rule in a public open-source code.
type SnykcoderuleExampleCommitFix struct {
	// CommitUrl Commit URL identifying a specific commit within a public open-source SCM repo.
	CommitUrl string `json:"commit_url"`

	// Lines Lines containing an example of the Snyk Code rule with an example fix.
	Lines []SnykcoderuleExampleCommitChange `json:"lines"`
}

// SnykcoderuleMultiformatMessageString Represent a message string in multiple formats: plain text or markdown.
type SnykcoderuleMultiformatMessageString struct {
	Markdown *string `json:"markdown,omitempty"`
	Text     *string `json:"text,omitempty"`
}

// SnykcoderuleProperties Additional properties of a Snyk Code rule. Represented in SARIF as free-form
// metadata, but Snyk Code scanner outputs prescribe a specific structure for
// this content.
type SnykcoderuleProperties struct {
	// Categories Categories applied to the rule.
	Categories []string `json:"categories"`

	// Cwe List of CWE (Common Weakness Enumeration) identifiers corresponding to this rule.
	Cwe []string `json:"cwe"`

	// ExampleCommitDescriptions Descriptions of the fix examples.
	ExampleCommitDescriptions []string `json:"example_commit_descriptions"`

	// ExampleCommitFixes Examples of fixing this rule in public open-source code.
	ExampleCommitFixes []SnykcoderuleExampleCommitFix `json:"example_commit_fixes"`

	// Precision A qualitative description of the rule's precision.
	Precision       string `json:"precision"`
	RepoDatasetSize uint32 `json:"repo_dataset_size"`

	// Tags Tags applied to the rule.
	Tags []string `json:"tags"`
}

// SnykvulndbBuildPackageEcosystem Software packages supporting the application build process.
//
// These are generally development libraries, which may be distributed in source
// or compiled form, used during the application build process by various
// programming language toolchains.
//
// Examples include, but are not limited to: Javascript NPM, Java Maven, Python pip, etc.
type SnykvulndbBuildPackageEcosystem struct {
	Language       string                              `json:"language"`
	PackageManager string                              `json:"package_manager"`
	Type           SnykvulndbBuildPackageEcosystemType `json:"type"`
}

// SnykvulndbBuildPackageEcosystemType defines model for SnykvulndbBuildPackageEcosystem.Type.
type SnykvulndbBuildPackageEcosystemType string

// SnykvulndbCvssScore defines model for snykvulndb.CvssScore.
type SnykvulndbCvssScore = float32

// SnykvulndbCvssSource CVSS vector information with provenance indicating the source of the scoring.
type SnykvulndbCvssSource struct {
	// Assigner Entity providing the CVSS information.
	Assigner string `json:"assigner"`

	// BaseScore Base CVSS score.
	BaseScore SnykvulndbCvssScore `json:"base_score"`

	// CvssVersion CVSS version.
	CvssVersion string `json:"cvss_version"`

	// ModifiedAt When the CVSS scoring was last modified.
	ModifiedAt time.Time `json:"modified_at"`

	// Severity Severity based on the CVSS rating scale (see SnykVulnAttributes.severity).
	Severity Severity `json:"severity"`

	// Type Designation of whether the CVSS score is primary (recommended assessment)
	// or secondary (supplemental information).
	Type SnykvulndbCvssSourceType `json:"type"`

	// Vector The CVSS vector string.
	Vector string `json:"vector"`
}

// SnykvulndbCvssSourceType Indicate whether the CVSS source is primary (recommended) or secondary
// (provided as supplemental information).
type SnykvulndbCvssSourceType string

// SnykvulndbEpssDetails Exploit Prediction Scoring System (EPSS), which predicts the likelihood (probability) of the vulnerability to be
// exploited, and the percentile of the EPSS of a vulnerability relative to all other vulnerabilities.
// We are using the latest model.
// https://www.first.org/epss/model
type SnykvulndbEpssDetails struct {
	// ModelVersion The version of the EPSS model we use.
	ModelVersion string `json:"model_version"`

	// Percentile The percentile of the EPSS of a vulnerability relative to all other vulnerabilities.
	// In value range 0 - 1 with 5 fixed digits.
	Percentile string `json:"percentile"`

	// Probability The probability of the vulnerability to be exploited.
	// In value range 0 - 1 with 5 fixed digits.
	Probability string `json:"probability"`
}

// SnykvulndbExploitDetails Details about the exploitability of a vulnerability.
type SnykvulndbExploitDetails struct {
	// MaturityLevels Exploit maturity representation in CVSS version formats.
	MaturityLevels []SnykvulndbExploitMaturityLevel `json:"maturity_levels"`

	// Sources Sources of the exploitation maturity assessment.
	Sources []string `json:"sources"`
}

// SnykvulndbExploitMaturityLevel Represents exploit maturity.
type SnykvulndbExploitMaturityLevel struct {
	// Format Format of the maturity level.
	Format string `json:"format"`

	// Level Maturity level in the given format.
	Level string `json:"level"`

	// Type Designation of whether the maturity information is primary (recommended
	// assessment) or secondary (supplemental information) in nature.
	Type SnykvulndbCvssSourceType `json:"type"`
}

// SnykvulndbLicenseInstructions License instructions are free-form, customer defined messages typically provided
// by application security or legal teams. They appear in the CLI alongside detected
// license violations to guide developers on how to handle specific licenses in their
// dependencies.
type SnykvulndbLicenseInstructions struct {
	// Content License policy instructions. Legal instructions for the user on what to do
	// when met with the license policy violation.
	Content string `json:"content"`

	// License Software license identifier.
	License string `json:"license"`
}

// SnykvulndbOsPackageEcosystem Software packages supporting operating system software installation and
// upgrades.
//
// These are generally software packages containing runtime libraries and
// applications which are installed as part of an operating system software
// distribution.
type SnykvulndbOsPackageEcosystem struct {
	// Distribution Distribution name providing the package.
	Distribution string `json:"distribution"`

	// OsName Name of the operating system.
	OsName string `json:"os_name"`

	// Release Release version of the operating system distribution.
	//
	// Note that for Linux distributions this is the release version (typically a
	// semver or date-derived number), rather than the codename for the release.
	Release string                           `json:"release"`
	Type    SnykvulndbOsPackageEcosystemType `json:"type"`
}

// SnykvulndbOsPackageEcosystemType defines model for SnykvulndbOsPackageEcosystem.Type.
type SnykvulndbOsPackageEcosystemType string

// SnykvulndbOtherPackageEcosystem Package ecosystem which this API version is not capable of expressing.
//
// More information may be available in a newer version of this API.
type SnykvulndbOtherPackageEcosystem struct {
	Type SnykvulndbOtherPackageEcosystemType `json:"type"`
}

// SnykvulndbOtherPackageEcosystemType defines model for SnykvulndbOtherPackageEcosystem.Type.
type SnykvulndbOtherPackageEcosystemType string

// SnykvulndbPackageEcosystem Describe a software package ecosystem.
type SnykvulndbPackageEcosystem struct {
	union json.RawMessage
}

// SnykvulndbReferenceLinks Represent links to external sources of vulnerability information.
type SnykvulndbReferenceLinks struct {
	// Title User-facing title of the link.
	Title string `json:"title"`

	// Url External link where more information about the vulnerability can be found.
	Url string `json:"url"`
}

// SnykvulndbVulnerableFunction Information about a function known to be vulnerable in a software package.
type SnykvulndbVulnerableFunction struct {
	// FunctionId Vulnerable function.
	FunctionId SnykvulndbVulnerableFunctionId `json:"function_id"`

	// Versions Package versions in which the function is vulnerable.
	Versions []string `json:"versions"`
}

// SnykvulndbVulnerableFunctionId Identify a vulnerable function in a software package.
type SnykvulndbVulnerableFunctionId struct {
	// ClassName Class containing the function.
	ClassName *string `json:"class_name,omitempty"`

	// FunctionName Vulnerable function name.
	FunctionName string `json:"function_name"`
}

// JobIdParam defines model for JobIdParam.
type JobIdParam = openapi_types.UUID

// OrgIdParam defines model for OrgIdParam.
type OrgIdParam = openapi_types.UUID

// TestIdParam defines model for TestIdParam.
type TestIdParam = openapi_types.UUID

// IoSnykApiRequestPaginatedRequestEndingBefore defines model for io.snyk.api.request.PaginatedRequest.ending_before.
type IoSnykApiRequestPaginatedRequestEndingBefore = string

// IoSnykApiRequestPaginatedRequestLimit defines model for io.snyk.api.request.PaginatedRequest.limit.
type IoSnykApiRequestPaginatedRequestLimit = int8

// IoSnykApiRequestPaginatedRequestStartingAfter defines model for io.snyk.api.request.PaginatedRequest.starting_after.
type IoSnykApiRequestPaginatedRequestStartingAfter = string

// IoSnykApiRequestSnykApiRequestInteractionId defines model for io.snyk.api.request.SnykApiRequest.interaction_id.
type IoSnykApiRequestSnykApiRequestInteractionId = string

// IoSnykApiRequestSnykApiRequestRequestId defines model for io.snyk.api.request.SnykApiRequest.request_id.
type IoSnykApiRequestSnykApiRequestRequestId = openapi_types.UUID

// IoSnykApiRequestSnykApiRequestVersion defines model for io.snyk.api.request.SnykApiRequest.version.
type IoSnykApiRequestSnykApiRequestVersion = string

// N400 defines model for 400.
type N400 = ErrorDocument

// N401 defines model for 401.
type N401 = ErrorDocument

// N404 defines model for 404.
type N404 = ErrorDocument

// N500 defines model for 500.
type N500 = ErrorDocument

// GetJobParams defines parameters for GetJob.
type GetJobParams struct {
	// Version The API version requested.
	Version IoSnykApiRequestSnykApiRequestVersion `form:"version" json:"version"`

	// SnykRequestId A unique ID assigned to each API request, for tracing and troubleshooting.
	//
	// Snyk clients can optionally provide this ID.
	SnykRequestId *IoSnykApiRequestSnykApiRequestRequestId `json:"snyk-request-id,omitempty"`

	// SnykInteractionId Identifies the Snyk client interaction in which this API request occurs.
	//
	// The identifier is an opaque string. though at the time of writing it may either be a
	// uuid or a urn containing a uuid and some metadata.
	SnykInteractionId *IoSnykApiRequestSnykApiRequestInteractionId `json:"snyk-interaction-id,omitempty"`
}

// CreateTestParams defines parameters for CreateTest.
type CreateTestParams struct {
	// Version The API version requested.
	Version IoSnykApiRequestSnykApiRequestVersion `form:"version" json:"version"`

	// SnykRequestId A unique ID assigned to each API request, for tracing and troubleshooting.
	//
	// Snyk clients can optionally provide this ID.
	SnykRequestId *IoSnykApiRequestSnykApiRequestRequestId `json:"snyk-request-id,omitempty"`

	// SnykInteractionId Identifies the Snyk client interaction in which this API request occurs.
	//
	// The identifier is an opaque string. though at the time of writing it may either be a
	// uuid or a urn containing a uuid and some metadata.
	SnykInteractionId *IoSnykApiRequestSnykApiRequestInteractionId `json:"snyk-interaction-id,omitempty"`
}

// GetTestParams defines parameters for GetTest.
type GetTestParams struct {
	// Version The API version requested.
	Version IoSnykApiRequestSnykApiRequestVersion `form:"version" json:"version"`

	// SnykRequestId A unique ID assigned to each API request, for tracing and troubleshooting.
	//
	// Snyk clients can optionally provide this ID.
	SnykRequestId *IoSnykApiRequestSnykApiRequestRequestId `json:"snyk-request-id,omitempty"`

	// SnykInteractionId Identifies the Snyk client interaction in which this API request occurs.
	//
	// The identifier is an opaque string. though at the time of writing it may either be a
	// uuid or a urn containing a uuid and some metadata.
	SnykInteractionId *IoSnykApiRequestSnykApiRequestInteractionId `json:"snyk-interaction-id,omitempty"`
}

// ListFindingsParams defines parameters for ListFindings.
type ListFindingsParams struct {
	// Version The API version requested.
	Version IoSnykApiRequestSnykApiRequestVersion `form:"version" json:"version"`

	// StartingAfter Opaque pagination cursor for forward traversal.
	StartingAfter *IoSnykApiRequestPaginatedRequestStartingAfter `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore Opaque pagination cursor for reverse traversal.
	EndingBefore *IoSnykApiRequestPaginatedRequestEndingBefore `form:"ending_before,omitempty" json:"ending_before,omitempty"`

	// Limit The number of items to return.
	Limit *IoSnykApiRequestPaginatedRequestLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SnykRequestId A unique ID assigned to each API request, for tracing and troubleshooting.
	//
	// Snyk clients can optionally provide this ID.
	SnykRequestId *IoSnykApiRequestSnykApiRequestRequestId `json:"snyk-request-id,omitempty"`

	// SnykInteractionId Identifies the Snyk client interaction in which this API request occurs.
	//
	// The identifier is an opaque string. though at the time of writing it may either be a
	// uuid or a urn containing a uuid and some metadata.
	SnykInteractionId *IoSnykApiRequestSnykApiRequestInteractionId `json:"snyk-interaction-id,omitempty"`
}

// CreateTestApplicationVndAPIPlusJSONRequestBody defines body for CreateTest for application/vnd.api+json ContentType.
type CreateTestApplicationVndAPIPlusJSONRequestBody = TestRequestBody

// Getter for additional properties for IoSnykApiCommonErrorLink. Returns the specified
// element and whether it was found
func (a IoSnykApiCommonErrorLink) Get(fieldName string) (value IoSnykApiCommonLinkProperty, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IoSnykApiCommonErrorLink
func (a *IoSnykApiCommonErrorLink) Set(fieldName string, value IoSnykApiCommonLinkProperty) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]IoSnykApiCommonLinkProperty)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IoSnykApiCommonErrorLink to handle AdditionalProperties
func (a *IoSnykApiCommonErrorLink) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["about"]; found {
		err = json.Unmarshal(raw, &a.About)
		if err != nil {
			return fmt.Errorf("error reading 'about': %w", err)
		}
		delete(object, "about")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]IoSnykApiCommonLinkProperty)
		for fieldName, fieldBuf := range object {
			var fieldVal IoSnykApiCommonLinkProperty
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IoSnykApiCommonErrorLink to handle AdditionalProperties
func (a IoSnykApiCommonErrorLink) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.About != nil {
		object["about"], err = json.Marshal(a.About)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'about': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IoSnykApiV1testdepgraphRequestDepGraph. Returns the specified
// element and whether it was found
func (a IoSnykApiV1testdepgraphRequestDepGraph) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IoSnykApiV1testdepgraphRequestDepGraph
func (a *IoSnykApiV1testdepgraphRequestDepGraph) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestDepGraph to handle AdditionalProperties
func (a *IoSnykApiV1testdepgraphRequestDepGraph) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["graph"]; found {
		err = json.Unmarshal(raw, &a.Graph)
		if err != nil {
			return fmt.Errorf("error reading 'graph': %w", err)
		}
		delete(object, "graph")
	}

	if raw, found := object["pkgManager"]; found {
		err = json.Unmarshal(raw, &a.PkgManager)
		if err != nil {
			return fmt.Errorf("error reading 'pkgManager': %w", err)
		}
		delete(object, "pkgManager")
	}

	if raw, found := object["pkgs"]; found {
		err = json.Unmarshal(raw, &a.Pkgs)
		if err != nil {
			return fmt.Errorf("error reading 'pkgs': %w", err)
		}
		delete(object, "pkgs")
	}

	if raw, found := object["schemaVersion"]; found {
		err = json.Unmarshal(raw, &a.SchemaVersion)
		if err != nil {
			return fmt.Errorf("error reading 'schemaVersion': %w", err)
		}
		delete(object, "schemaVersion")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestDepGraph to handle AdditionalProperties
func (a IoSnykApiV1testdepgraphRequestDepGraph) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["graph"], err = json.Marshal(a.Graph)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'graph': %w", err)
	}

	object["pkgManager"], err = json.Marshal(a.PkgManager)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pkgManager': %w", err)
	}

	object["pkgs"], err = json.Marshal(a.Pkgs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pkgs': %w", err)
	}

	object["schemaVersion"], err = json.Marshal(a.SchemaVersion)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'schemaVersion': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IoSnykApiV1testdepgraphRequestGraph. Returns the specified
// element and whether it was found
func (a IoSnykApiV1testdepgraphRequestGraph) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IoSnykApiV1testdepgraphRequestGraph
func (a *IoSnykApiV1testdepgraphRequestGraph) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestGraph to handle AdditionalProperties
func (a *IoSnykApiV1testdepgraphRequestGraph) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nodes"]; found {
		err = json.Unmarshal(raw, &a.Nodes)
		if err != nil {
			return fmt.Errorf("error reading 'nodes': %w", err)
		}
		delete(object, "nodes")
	}

	if raw, found := object["rootNodeId"]; found {
		err = json.Unmarshal(raw, &a.RootNodeId)
		if err != nil {
			return fmt.Errorf("error reading 'rootNodeId': %w", err)
		}
		delete(object, "rootNodeId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestGraph to handle AdditionalProperties
func (a IoSnykApiV1testdepgraphRequestGraph) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nodes"], err = json.Marshal(a.Nodes)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nodes': %w", err)
	}

	object["rootNodeId"], err = json.Marshal(a.RootNodeId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'rootNodeId': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IoSnykApiV1testdepgraphRequestNode. Returns the specified
// element and whether it was found
func (a IoSnykApiV1testdepgraphRequestNode) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IoSnykApiV1testdepgraphRequestNode
func (a *IoSnykApiV1testdepgraphRequestNode) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestNode to handle AdditionalProperties
func (a *IoSnykApiV1testdepgraphRequestNode) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["deps"]; found {
		err = json.Unmarshal(raw, &a.Deps)
		if err != nil {
			return fmt.Errorf("error reading 'deps': %w", err)
		}
		delete(object, "deps")
	}

	if raw, found := object["nodeId"]; found {
		err = json.Unmarshal(raw, &a.NodeId)
		if err != nil {
			return fmt.Errorf("error reading 'nodeId': %w", err)
		}
		delete(object, "nodeId")
	}

	if raw, found := object["pkgId"]; found {
		err = json.Unmarshal(raw, &a.PkgId)
		if err != nil {
			return fmt.Errorf("error reading 'pkgId': %w", err)
		}
		delete(object, "pkgId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestNode to handle AdditionalProperties
func (a IoSnykApiV1testdepgraphRequestNode) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["deps"], err = json.Marshal(a.Deps)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'deps': %w", err)
	}

	object["nodeId"], err = json.Marshal(a.NodeId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nodeId': %w", err)
	}

	object["pkgId"], err = json.Marshal(a.PkgId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pkgId': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IoSnykApiV1testdepgraphRequestNodeRef. Returns the specified
// element and whether it was found
func (a IoSnykApiV1testdepgraphRequestNodeRef) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IoSnykApiV1testdepgraphRequestNodeRef
func (a *IoSnykApiV1testdepgraphRequestNodeRef) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestNodeRef to handle AdditionalProperties
func (a *IoSnykApiV1testdepgraphRequestNodeRef) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nodeId"]; found {
		err = json.Unmarshal(raw, &a.NodeId)
		if err != nil {
			return fmt.Errorf("error reading 'nodeId': %w", err)
		}
		delete(object, "nodeId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestNodeRef to handle AdditionalProperties
func (a IoSnykApiV1testdepgraphRequestNodeRef) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nodeId"], err = json.Marshal(a.NodeId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nodeId': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IoSnykApiV1testdepgraphRequestPackage. Returns the specified
// element and whether it was found
func (a IoSnykApiV1testdepgraphRequestPackage) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IoSnykApiV1testdepgraphRequestPackage
func (a *IoSnykApiV1testdepgraphRequestPackage) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestPackage to handle AdditionalProperties
func (a *IoSnykApiV1testdepgraphRequestPackage) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["info"]; found {
		err = json.Unmarshal(raw, &a.Info)
		if err != nil {
			return fmt.Errorf("error reading 'info': %w", err)
		}
		delete(object, "info")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestPackage to handle AdditionalProperties
func (a IoSnykApiV1testdepgraphRequestPackage) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["info"], err = json.Marshal(a.Info)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'info': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IoSnykApiV1testdepgraphRequestPackageInfo. Returns the specified
// element and whether it was found
func (a IoSnykApiV1testdepgraphRequestPackageInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IoSnykApiV1testdepgraphRequestPackageInfo
func (a *IoSnykApiV1testdepgraphRequestPackageInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestPackageInfo to handle AdditionalProperties
func (a *IoSnykApiV1testdepgraphRequestPackageInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestPackageInfo to handle AdditionalProperties
func (a IoSnykApiV1testdepgraphRequestPackageInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IoSnykApiV1testdepgraphRequestPackageManager. Returns the specified
// element and whether it was found
func (a IoSnykApiV1testdepgraphRequestPackageManager) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IoSnykApiV1testdepgraphRequestPackageManager
func (a *IoSnykApiV1testdepgraphRequestPackageManager) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestPackageManager to handle AdditionalProperties
func (a *IoSnykApiV1testdepgraphRequestPackageManager) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IoSnykApiV1testdepgraphRequestPackageManager to handle AdditionalProperties
func (a IoSnykApiV1testdepgraphRequestPackageManager) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsUpgradePackageAction returns the union data inside the Action as a UpgradePackageAction
func (t Action) AsUpgradePackageAction() (UpgradePackageAction, error) {
	var body UpgradePackageAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpgradePackageAction overwrites any union data inside the Action as the provided UpgradePackageAction
func (t *Action) FromUpgradePackageAction(v UpgradePackageAction) error {
	v.Type = "upgrade_package"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpgradePackageAction performs a merge with any union data inside the Action, using the provided UpgradePackageAction
func (t *Action) MergeUpgradePackageAction(v UpgradePackageAction) error {
	v.Type = "upgrade_package"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPinPackageAction returns the union data inside the Action as a PinPackageAction
func (t Action) AsPinPackageAction() (PinPackageAction, error) {
	var body PinPackageAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPinPackageAction overwrites any union data inside the Action as the provided PinPackageAction
func (t *Action) FromPinPackageAction(v PinPackageAction) error {
	v.Type = "pin_package"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePinPackageAction performs a merge with any union data inside the Action, using the provided PinPackageAction
func (t *Action) MergePinPackageAction(v PinPackageAction) error {
	v.Type = "pin_package"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Action) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Action) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "pin_package":
		return t.AsPinPackageAction()
	case "upgrade_package":
		return t.AsUpgradePackageAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Action) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Action) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSeverityChange returns the union data inside the AppliedPolicy as a SeverityChange
func (t AppliedPolicy) AsSeverityChange() (SeverityChange, error) {
	var body SeverityChange
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSeverityChange overwrites any union data inside the AppliedPolicy as the provided SeverityChange
func (t *AppliedPolicy) FromSeverityChange(v SeverityChange) error {
	v.ActionType = "severity-change"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSeverityChange performs a merge with any union data inside the AppliedPolicy, using the provided SeverityChange
func (t *AppliedPolicy) MergeSeverityChange(v SeverityChange) error {
	v.ActionType = "severity-change"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIgnore returns the union data inside the AppliedPolicy as a Ignore
func (t AppliedPolicy) AsIgnore() (Ignore, error) {
	var body Ignore
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIgnore overwrites any union data inside the AppliedPolicy as the provided Ignore
func (t *AppliedPolicy) FromIgnore(v Ignore) error {
	v.ActionType = "ignore"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIgnore performs a merge with any union data inside the AppliedPolicy, using the provided Ignore
func (t *AppliedPolicy) MergeIgnore(v Ignore) error {
	v.ActionType = "ignore"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppliedPolicy) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppliedPolicy) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ignore":
		return t.AsIgnore()
	case "severity-change":
		return t.AsSeverityChange()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppliedPolicy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AppliedPolicy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDependencyPathEvidence returns the union data inside the Evidence as a DependencyPathEvidence
func (t Evidence) AsDependencyPathEvidence() (DependencyPathEvidence, error) {
	var body DependencyPathEvidence
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDependencyPathEvidence overwrites any union data inside the Evidence as the provided DependencyPathEvidence
func (t *Evidence) FromDependencyPathEvidence(v DependencyPathEvidence) error {
	v.Source = "dependency_path"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDependencyPathEvidence performs a merge with any union data inside the Evidence, using the provided DependencyPathEvidence
func (t *Evidence) MergeDependencyPathEvidence(v DependencyPathEvidence) error {
	v.Source = "dependency_path"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExecutionFlowEvidence returns the union data inside the Evidence as a ExecutionFlowEvidence
func (t Evidence) AsExecutionFlowEvidence() (ExecutionFlowEvidence, error) {
	var body ExecutionFlowEvidence
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExecutionFlowEvidence overwrites any union data inside the Evidence as the provided ExecutionFlowEvidence
func (t *Evidence) FromExecutionFlowEvidence(v ExecutionFlowEvidence) error {
	v.Source = "execution_flow"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExecutionFlowEvidence performs a merge with any union data inside the Evidence, using the provided ExecutionFlowEvidence
func (t *Evidence) MergeExecutionFlowEvidence(v ExecutionFlowEvidence) error {
	v.Source = "execution_flow"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReachabilityEvidence returns the union data inside the Evidence as a ReachabilityEvidence
func (t Evidence) AsReachabilityEvidence() (ReachabilityEvidence, error) {
	var body ReachabilityEvidence
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReachabilityEvidence overwrites any union data inside the Evidence as the provided ReachabilityEvidence
func (t *Evidence) FromReachabilityEvidence(v ReachabilityEvidence) error {
	v.Source = "reachability"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReachabilityEvidence performs a merge with any union data inside the Evidence, using the provided ReachabilityEvidence
func (t *Evidence) MergeReachabilityEvidence(v ReachabilityEvidence) error {
	v.Source = "reachability"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtherEvidence returns the union data inside the Evidence as a OtherEvidence
func (t Evidence) AsOtherEvidence() (OtherEvidence, error) {
	var body OtherEvidence
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtherEvidence overwrites any union data inside the Evidence as the provided OtherEvidence
func (t *Evidence) FromOtherEvidence(v OtherEvidence) error {
	v.Source = "other"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtherEvidence performs a merge with any union data inside the Evidence, using the provided OtherEvidence
func (t *Evidence) MergeOtherEvidence(v OtherEvidence) error {
	v.Source = "other"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Evidence) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"source"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Evidence) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dependency_path":
		return t.AsDependencyPathEvidence()
	case "execution_flow":
		return t.AsExecutionFlowEvidence()
	case "other":
		return t.AsOtherEvidence()
	case "reachability":
		return t.AsReachabilityEvidence()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Evidence) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Evidence) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageLocation returns the union data inside the FindingLocation as a PackageLocation
func (t FindingLocation) AsPackageLocation() (PackageLocation, error) {
	var body PackageLocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageLocation overwrites any union data inside the FindingLocation as the provided PackageLocation
func (t *FindingLocation) FromPackageLocation(v PackageLocation) error {
	v.Type = "package"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageLocation performs a merge with any union data inside the FindingLocation, using the provided PackageLocation
func (t *FindingLocation) MergePackageLocation(v PackageLocation) error {
	v.Type = "package"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSourceLocation returns the union data inside the FindingLocation as a SourceLocation
func (t FindingLocation) AsSourceLocation() (SourceLocation, error) {
	var body SourceLocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSourceLocation overwrites any union data inside the FindingLocation as the provided SourceLocation
func (t *FindingLocation) FromSourceLocation(v SourceLocation) error {
	v.Type = "source"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSourceLocation performs a merge with any union data inside the FindingLocation, using the provided SourceLocation
func (t *FindingLocation) MergeSourceLocation(v SourceLocation) error {
	v.Type = "source"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtherLocation returns the union data inside the FindingLocation as a OtherLocation
func (t FindingLocation) AsOtherLocation() (OtherLocation, error) {
	var body OtherLocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtherLocation overwrites any union data inside the FindingLocation as the provided OtherLocation
func (t *FindingLocation) FromOtherLocation(v OtherLocation) error {
	v.Type = "other"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtherLocation performs a merge with any union data inside the FindingLocation, using the provided OtherLocation
func (t *FindingLocation) MergeOtherLocation(v OtherLocation) error {
	v.Type = "other"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FindingLocation) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t FindingLocation) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "other":
		return t.AsOtherLocation()
	case "package":
		return t.AsPackageLocation()
	case "source":
		return t.AsSourceLocation()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t FindingLocation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FindingLocation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLinkProperty0 returns the union data inside the LinkProperty as a LinkProperty0
func (t LinkProperty) AsLinkProperty0() (LinkProperty0, error) {
	var body LinkProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkProperty0 overwrites any union data inside the LinkProperty as the provided LinkProperty0
func (t *LinkProperty) FromLinkProperty0(v LinkProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkProperty0 performs a merge with any union data inside the LinkProperty, using the provided LinkProperty0
func (t *LinkProperty) MergeLinkProperty0(v LinkProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkProperty1 returns the union data inside the LinkProperty as a LinkProperty1
func (t LinkProperty) AsLinkProperty1() (LinkProperty1, error) {
	var body LinkProperty1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkProperty1 overwrites any union data inside the LinkProperty as the provided LinkProperty1
func (t *LinkProperty) FromLinkProperty1(v LinkProperty1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkProperty1 performs a merge with any union data inside the LinkProperty, using the provided LinkProperty1
func (t *LinkProperty) MergeLinkProperty1(v LinkProperty1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LinkProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LinkProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPolicyRef0 returns the union data inside the PolicyRef as a PolicyRef0
func (t PolicyRef) AsPolicyRef0() (PolicyRef0, error) {
	var body PolicyRef0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPolicyRef0 overwrites any union data inside the PolicyRef as the provided PolicyRef0
func (t *PolicyRef) FromPolicyRef0(v PolicyRef0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePolicyRef0 performs a merge with any union data inside the PolicyRef, using the provided PolicyRef0
func (t *PolicyRef) MergePolicyRef0(v PolicyRef0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsManagedPolicyRef returns the union data inside the PolicyRef as a ManagedPolicyRef
func (t PolicyRef) AsManagedPolicyRef() (ManagedPolicyRef, error) {
	var body ManagedPolicyRef
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromManagedPolicyRef overwrites any union data inside the PolicyRef as the provided ManagedPolicyRef
func (t *PolicyRef) FromManagedPolicyRef(v ManagedPolicyRef) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeManagedPolicyRef performs a merge with any union data inside the PolicyRef, using the provided ManagedPolicyRef
func (t *PolicyRef) MergeManagedPolicyRef(v ManagedPolicyRef) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PolicyRef) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PolicyRef) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCweProblem returns the union data inside the Problem as a CweProblem
func (t Problem) AsCweProblem() (CweProblem, error) {
	var body CweProblem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCweProblem overwrites any union data inside the Problem as the provided CweProblem
func (t *Problem) FromCweProblem(v CweProblem) error {
	v.Source = "cwe"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCweProblem performs a merge with any union data inside the Problem, using the provided CweProblem
func (t *Problem) MergeCweProblem(v CweProblem) error {
	v.Source = "cwe"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnykCodeRuleProblem returns the union data inside the Problem as a SnykCodeRuleProblem
func (t Problem) AsSnykCodeRuleProblem() (SnykCodeRuleProblem, error) {
	var body SnykCodeRuleProblem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnykCodeRuleProblem overwrites any union data inside the Problem as the provided SnykCodeRuleProblem
func (t *Problem) FromSnykCodeRuleProblem(v SnykCodeRuleProblem) error {
	v.Source = "snyk_code_rule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnykCodeRuleProblem performs a merge with any union data inside the Problem, using the provided SnykCodeRuleProblem
func (t *Problem) MergeSnykCodeRuleProblem(v SnykCodeRuleProblem) error {
	v.Source = "snyk_code_rule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCveProblem returns the union data inside the Problem as a CveProblem
func (t Problem) AsCveProblem() (CveProblem, error) {
	var body CveProblem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCveProblem overwrites any union data inside the Problem as the provided CveProblem
func (t *Problem) FromCveProblem(v CveProblem) error {
	v.Source = "cve"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCveProblem performs a merge with any union data inside the Problem, using the provided CveProblem
func (t *Problem) MergeCveProblem(v CveProblem) error {
	v.Source = "cve"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnykVulnProblem returns the union data inside the Problem as a SnykVulnProblem
func (t Problem) AsSnykVulnProblem() (SnykVulnProblem, error) {
	var body SnykVulnProblem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnykVulnProblem overwrites any union data inside the Problem as the provided SnykVulnProblem
func (t *Problem) FromSnykVulnProblem(v SnykVulnProblem) error {
	v.Source = "snyk_vuln"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnykVulnProblem performs a merge with any union data inside the Problem, using the provided SnykVulnProblem
func (t *Problem) MergeSnykVulnProblem(v SnykVulnProblem) error {
	v.Source = "snyk_vuln"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnykLicenseProblem returns the union data inside the Problem as a SnykLicenseProblem
func (t Problem) AsSnykLicenseProblem() (SnykLicenseProblem, error) {
	var body SnykLicenseProblem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnykLicenseProblem overwrites any union data inside the Problem as the provided SnykLicenseProblem
func (t *Problem) FromSnykLicenseProblem(v SnykLicenseProblem) error {
	v.Source = "snyk_license"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnykLicenseProblem performs a merge with any union data inside the Problem, using the provided SnykLicenseProblem
func (t *Problem) MergeSnykLicenseProblem(v SnykLicenseProblem) error {
	v.Source = "snyk_license"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnykCloudRuleProblem returns the union data inside the Problem as a SnykCloudRuleProblem
func (t Problem) AsSnykCloudRuleProblem() (SnykCloudRuleProblem, error) {
	var body SnykCloudRuleProblem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnykCloudRuleProblem overwrites any union data inside the Problem as the provided SnykCloudRuleProblem
func (t *Problem) FromSnykCloudRuleProblem(v SnykCloudRuleProblem) error {
	v.Source = "snyk_cloud_rule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnykCloudRuleProblem performs a merge with any union data inside the Problem, using the provided SnykCloudRuleProblem
func (t *Problem) MergeSnykCloudRuleProblem(v SnykCloudRuleProblem) error {
	v.Source = "snyk_cloud_rule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGithubSecurityAdvisoryProblem returns the union data inside the Problem as a GithubSecurityAdvisoryProblem
func (t Problem) AsGithubSecurityAdvisoryProblem() (GithubSecurityAdvisoryProblem, error) {
	var body GithubSecurityAdvisoryProblem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGithubSecurityAdvisoryProblem overwrites any union data inside the Problem as the provided GithubSecurityAdvisoryProblem
func (t *Problem) FromGithubSecurityAdvisoryProblem(v GithubSecurityAdvisoryProblem) error {
	v.Source = "ghsa"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGithubSecurityAdvisoryProblem performs a merge with any union data inside the Problem, using the provided GithubSecurityAdvisoryProblem
func (t *Problem) MergeGithubSecurityAdvisoryProblem(v GithubSecurityAdvisoryProblem) error {
	v.Source = "ghsa"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtherProblem returns the union data inside the Problem as a OtherProblem
func (t Problem) AsOtherProblem() (OtherProblem, error) {
	var body OtherProblem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtherProblem overwrites any union data inside the Problem as the provided OtherProblem
func (t *Problem) FromOtherProblem(v OtherProblem) error {
	v.Source = "other"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtherProblem performs a merge with any union data inside the Problem, using the provided OtherProblem
func (t *Problem) MergeOtherProblem(v OtherProblem) error {
	v.Source = "other"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Problem) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"source"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Problem) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "cve":
		return t.AsCveProblem()
	case "cwe":
		return t.AsCweProblem()
	case "ghsa":
		return t.AsGithubSecurityAdvisoryProblem()
	case "other":
		return t.AsOtherProblem()
	case "snyk_cloud_rule":
		return t.AsSnykCloudRuleProblem()
	case "snyk_code_rule":
		return t.AsSnykCodeRuleProblem()
	case "snyk_license":
		return t.AsSnykLicenseProblem()
	case "snyk_vuln":
		return t.AsSnykVulnProblem()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Problem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Problem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeepcodeBundleSubject returns the union data inside the TestSubject as a DeepcodeBundleSubject
func (t TestSubject) AsDeepcodeBundleSubject() (DeepcodeBundleSubject, error) {
	var body DeepcodeBundleSubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeepcodeBundleSubject overwrites any union data inside the TestSubject as the provided DeepcodeBundleSubject
func (t *TestSubject) FromDeepcodeBundleSubject(v DeepcodeBundleSubject) error {
	v.Type = "deepcode_bundle"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeepcodeBundleSubject performs a merge with any union data inside the TestSubject, using the provided DeepcodeBundleSubject
func (t *TestSubject) MergeDeepcodeBundleSubject(v DeepcodeBundleSubject) error {
	v.Type = "deepcode_bundle"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDepGraphSubject returns the union data inside the TestSubject as a DepGraphSubject
func (t TestSubject) AsDepGraphSubject() (DepGraphSubject, error) {
	var body DepGraphSubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDepGraphSubject overwrites any union data inside the TestSubject as the provided DepGraphSubject
func (t *TestSubject) FromDepGraphSubject(v DepGraphSubject) error {
	v.Type = "dep_graph"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDepGraphSubject performs a merge with any union data inside the TestSubject, using the provided DepGraphSubject
func (t *TestSubject) MergeDepGraphSubject(v DepGraphSubject) error {
	v.Type = "dep_graph"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGitUrlCoordinatesSubject returns the union data inside the TestSubject as a GitUrlCoordinatesSubject
func (t TestSubject) AsGitUrlCoordinatesSubject() (GitUrlCoordinatesSubject, error) {
	var body GitUrlCoordinatesSubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGitUrlCoordinatesSubject overwrites any union data inside the TestSubject as the provided GitUrlCoordinatesSubject
func (t *TestSubject) FromGitUrlCoordinatesSubject(v GitUrlCoordinatesSubject) error {
	v.Type = "git_url_coordinates"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGitUrlCoordinatesSubject performs a merge with any union data inside the TestSubject, using the provided GitUrlCoordinatesSubject
func (t *TestSubject) MergeGitUrlCoordinatesSubject(v GitUrlCoordinatesSubject) error {
	v.Type = "git_url_coordinates"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSbomReachabilitySubject returns the union data inside the TestSubject as a SbomReachabilitySubject
func (t TestSubject) AsSbomReachabilitySubject() (SbomReachabilitySubject, error) {
	var body SbomReachabilitySubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSbomReachabilitySubject overwrites any union data inside the TestSubject as the provided SbomReachabilitySubject
func (t *TestSubject) FromSbomReachabilitySubject(v SbomReachabilitySubject) error {
	v.Type = "sbom_reachability"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSbomReachabilitySubject performs a merge with any union data inside the TestSubject, using the provided SbomReachabilitySubject
func (t *TestSubject) MergeSbomReachabilitySubject(v SbomReachabilitySubject) error {
	v.Type = "sbom_reachability"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtherSubject returns the union data inside the TestSubject as a OtherSubject
func (t TestSubject) AsOtherSubject() (OtherSubject, error) {
	var body OtherSubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtherSubject overwrites any union data inside the TestSubject as the provided OtherSubject
func (t *TestSubject) FromOtherSubject(v OtherSubject) error {
	v.Type = "other"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtherSubject performs a merge with any union data inside the TestSubject, using the provided OtherSubject
func (t *TestSubject) MergeOtherSubject(v OtherSubject) error {
	v.Type = "other"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSbomSubject returns the union data inside the TestSubject as a SbomSubject
func (t TestSubject) AsSbomSubject() (SbomSubject, error) {
	var body SbomSubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSbomSubject overwrites any union data inside the TestSubject as the provided SbomSubject
func (t *TestSubject) FromSbomSubject(v SbomSubject) error {
	v.Type = "sbom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSbomSubject performs a merge with any union data inside the TestSubject, using the provided SbomSubject
func (t *TestSubject) MergeSbomSubject(v SbomSubject) error {
	v.Type = "sbom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TestSubject) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TestSubject) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "deepcode_bundle":
		return t.AsDeepcodeBundleSubject()
	case "dep_graph":
		return t.AsDepGraphSubject()
	case "git_url_coordinates":
		return t.AsGitUrlCoordinatesSubject()
	case "other":
		return t.AsOtherSubject()
	case "sbom":
		return t.AsSbomSubject()
	case "sbom_reachability":
		return t.AsSbomReachabilitySubject()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TestSubject) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TestSubject) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeepcodeBundleSubject returns the union data inside the TestSubjectCreate as a DeepcodeBundleSubject
func (t TestSubjectCreate) AsDeepcodeBundleSubject() (DeepcodeBundleSubject, error) {
	var body DeepcodeBundleSubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeepcodeBundleSubject overwrites any union data inside the TestSubjectCreate as the provided DeepcodeBundleSubject
func (t *TestSubjectCreate) FromDeepcodeBundleSubject(v DeepcodeBundleSubject) error {
	v.Type = "deepcode_bundle"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeepcodeBundleSubject performs a merge with any union data inside the TestSubjectCreate, using the provided DeepcodeBundleSubject
func (t *TestSubjectCreate) MergeDeepcodeBundleSubject(v DeepcodeBundleSubject) error {
	v.Type = "deepcode_bundle"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDepGraphSubjectCreate returns the union data inside the TestSubjectCreate as a DepGraphSubjectCreate
func (t TestSubjectCreate) AsDepGraphSubjectCreate() (DepGraphSubjectCreate, error) {
	var body DepGraphSubjectCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDepGraphSubjectCreate overwrites any union data inside the TestSubjectCreate as the provided DepGraphSubjectCreate
func (t *TestSubjectCreate) FromDepGraphSubjectCreate(v DepGraphSubjectCreate) error {
	v.Type = "dep_graph"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDepGraphSubjectCreate performs a merge with any union data inside the TestSubjectCreate, using the provided DepGraphSubjectCreate
func (t *TestSubjectCreate) MergeDepGraphSubjectCreate(v DepGraphSubjectCreate) error {
	v.Type = "dep_graph"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGitUrlCoordinatesSubject returns the union data inside the TestSubjectCreate as a GitUrlCoordinatesSubject
func (t TestSubjectCreate) AsGitUrlCoordinatesSubject() (GitUrlCoordinatesSubject, error) {
	var body GitUrlCoordinatesSubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGitUrlCoordinatesSubject overwrites any union data inside the TestSubjectCreate as the provided GitUrlCoordinatesSubject
func (t *TestSubjectCreate) FromGitUrlCoordinatesSubject(v GitUrlCoordinatesSubject) error {
	v.Type = "git_url_coordinates"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGitUrlCoordinatesSubject performs a merge with any union data inside the TestSubjectCreate, using the provided GitUrlCoordinatesSubject
func (t *TestSubjectCreate) MergeGitUrlCoordinatesSubject(v GitUrlCoordinatesSubject) error {
	v.Type = "git_url_coordinates"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSbomReachabilitySubject returns the union data inside the TestSubjectCreate as a SbomReachabilitySubject
func (t TestSubjectCreate) AsSbomReachabilitySubject() (SbomReachabilitySubject, error) {
	var body SbomReachabilitySubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSbomReachabilitySubject overwrites any union data inside the TestSubjectCreate as the provided SbomReachabilitySubject
func (t *TestSubjectCreate) FromSbomReachabilitySubject(v SbomReachabilitySubject) error {
	v.Type = "sbom_reachability"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSbomReachabilitySubject performs a merge with any union data inside the TestSubjectCreate, using the provided SbomReachabilitySubject
func (t *TestSubjectCreate) MergeSbomReachabilitySubject(v SbomReachabilitySubject) error {
	v.Type = "sbom_reachability"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtherSubject returns the union data inside the TestSubjectCreate as a OtherSubject
func (t TestSubjectCreate) AsOtherSubject() (OtherSubject, error) {
	var body OtherSubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtherSubject overwrites any union data inside the TestSubjectCreate as the provided OtherSubject
func (t *TestSubjectCreate) FromOtherSubject(v OtherSubject) error {
	v.Type = "other"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtherSubject performs a merge with any union data inside the TestSubjectCreate, using the provided OtherSubject
func (t *TestSubjectCreate) MergeOtherSubject(v OtherSubject) error {
	v.Type = "other"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSbomSubject returns the union data inside the TestSubjectCreate as a SbomSubject
func (t TestSubjectCreate) AsSbomSubject() (SbomSubject, error) {
	var body SbomSubject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSbomSubject overwrites any union data inside the TestSubjectCreate as the provided SbomSubject
func (t *TestSubjectCreate) FromSbomSubject(v SbomSubject) error {
	v.Type = "sbom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSbomSubject performs a merge with any union data inside the TestSubjectCreate, using the provided SbomSubject
func (t *TestSubjectCreate) MergeSbomSubject(v SbomSubject) error {
	v.Type = "sbom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TestSubjectCreate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TestSubjectCreate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "deepcode_bundle":
		return t.AsDeepcodeBundleSubject()
	case "dep_graph":
		return t.AsDepGraphSubjectCreate()
	case "git_url_coordinates":
		return t.AsGitUrlCoordinatesSubject()
	case "other":
		return t.AsOtherSubject()
	case "sbom":
		return t.AsSbomSubject()
	case "sbom_reachability":
		return t.AsSbomReachabilitySubject()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TestSubjectCreate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TestSubjectCreate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProjectEntityLocator returns the union data inside the TestSubjectLocator as a ProjectEntityLocator
func (t TestSubjectLocator) AsProjectEntityLocator() (ProjectEntityLocator, error) {
	var body ProjectEntityLocator
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProjectEntityLocator overwrites any union data inside the TestSubjectLocator as the provided ProjectEntityLocator
func (t *TestSubjectLocator) FromProjectEntityLocator(v ProjectEntityLocator) error {
	v.Type = "project_entity"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProjectEntityLocator performs a merge with any union data inside the TestSubjectLocator, using the provided ProjectEntityLocator
func (t *TestSubjectLocator) MergeProjectEntityLocator(v ProjectEntityLocator) error {
	v.Type = "project_entity"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProjectNameLocator returns the union data inside the TestSubjectLocator as a ProjectNameLocator
func (t TestSubjectLocator) AsProjectNameLocator() (ProjectNameLocator, error) {
	var body ProjectNameLocator
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProjectNameLocator overwrites any union data inside the TestSubjectLocator as the provided ProjectNameLocator
func (t *TestSubjectLocator) FromProjectNameLocator(v ProjectNameLocator) error {
	v.Type = "project_name"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProjectNameLocator performs a merge with any union data inside the TestSubjectLocator, using the provided ProjectNameLocator
func (t *TestSubjectLocator) MergeProjectNameLocator(v ProjectNameLocator) error {
	v.Type = "project_name"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScmRepoLocator returns the union data inside the TestSubjectLocator as a ScmRepoLocator
func (t TestSubjectLocator) AsScmRepoLocator() (ScmRepoLocator, error) {
	var body ScmRepoLocator
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScmRepoLocator overwrites any union data inside the TestSubjectLocator as the provided ScmRepoLocator
func (t *TestSubjectLocator) FromScmRepoLocator(v ScmRepoLocator) error {
	v.Type = "scm_repo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScmRepoLocator performs a merge with any union data inside the TestSubjectLocator, using the provided ScmRepoLocator
func (t *TestSubjectLocator) MergeScmRepoLocator(v ScmRepoLocator) error {
	v.Type = "scm_repo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocalPathLocator returns the union data inside the TestSubjectLocator as a LocalPathLocator
func (t TestSubjectLocator) AsLocalPathLocator() (LocalPathLocator, error) {
	var body LocalPathLocator
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocalPathLocator overwrites any union data inside the TestSubjectLocator as the provided LocalPathLocator
func (t *TestSubjectLocator) FromLocalPathLocator(v LocalPathLocator) error {
	v.Type = "local_path"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocalPathLocator performs a merge with any union data inside the TestSubjectLocator, using the provided LocalPathLocator
func (t *TestSubjectLocator) MergeLocalPathLocator(v LocalPathLocator) error {
	v.Type = "local_path"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtherLocator returns the union data inside the TestSubjectLocator as a OtherLocator
func (t TestSubjectLocator) AsOtherLocator() (OtherLocator, error) {
	var body OtherLocator
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtherLocator overwrites any union data inside the TestSubjectLocator as the provided OtherLocator
func (t *TestSubjectLocator) FromOtherLocator(v OtherLocator) error {
	v.Type = "other"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtherLocator performs a merge with any union data inside the TestSubjectLocator, using the provided OtherLocator
func (t *TestSubjectLocator) MergeOtherLocator(v OtherLocator) error {
	v.Type = "other"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TestSubjectLocator) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TestSubjectLocator) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "local_path":
		return t.AsLocalPathLocator()
	case "other":
		return t.AsOtherLocator()
	case "project_entity":
		return t.AsProjectEntityLocator()
	case "project_name":
		return t.AsProjectNameLocator()
	case "scm_repo":
		return t.AsScmRepoLocator()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TestSubjectLocator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TestSubjectLocator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIoSnykApiCommonLinkString returns the union data inside the IoSnykApiCommonLinkProperty as a IoSnykApiCommonLinkString
func (t IoSnykApiCommonLinkProperty) AsIoSnykApiCommonLinkString() (IoSnykApiCommonLinkString, error) {
	var body IoSnykApiCommonLinkString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIoSnykApiCommonLinkString overwrites any union data inside the IoSnykApiCommonLinkProperty as the provided IoSnykApiCommonLinkString
func (t *IoSnykApiCommonLinkProperty) FromIoSnykApiCommonLinkString(v IoSnykApiCommonLinkString) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIoSnykApiCommonLinkString performs a merge with any union data inside the IoSnykApiCommonLinkProperty, using the provided IoSnykApiCommonLinkString
func (t *IoSnykApiCommonLinkProperty) MergeIoSnykApiCommonLinkString(v IoSnykApiCommonLinkString) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIoSnykApiCommonLinkObject returns the union data inside the IoSnykApiCommonLinkProperty as a IoSnykApiCommonLinkObject
func (t IoSnykApiCommonLinkProperty) AsIoSnykApiCommonLinkObject() (IoSnykApiCommonLinkObject, error) {
	var body IoSnykApiCommonLinkObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIoSnykApiCommonLinkObject overwrites any union data inside the IoSnykApiCommonLinkProperty as the provided IoSnykApiCommonLinkObject
func (t *IoSnykApiCommonLinkProperty) FromIoSnykApiCommonLinkObject(v IoSnykApiCommonLinkObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIoSnykApiCommonLinkObject performs a merge with any union data inside the IoSnykApiCommonLinkProperty, using the provided IoSnykApiCommonLinkObject
func (t *IoSnykApiCommonLinkProperty) MergeIoSnykApiCommonLinkObject(v IoSnykApiCommonLinkObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IoSnykApiCommonLinkProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IoSnykApiCommonLinkProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSnykvulndbBuildPackageEcosystem returns the union data inside the SnykvulndbPackageEcosystem as a SnykvulndbBuildPackageEcosystem
func (t SnykvulndbPackageEcosystem) AsSnykvulndbBuildPackageEcosystem() (SnykvulndbBuildPackageEcosystem, error) {
	var body SnykvulndbBuildPackageEcosystem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnykvulndbBuildPackageEcosystem overwrites any union data inside the SnykvulndbPackageEcosystem as the provided SnykvulndbBuildPackageEcosystem
func (t *SnykvulndbPackageEcosystem) FromSnykvulndbBuildPackageEcosystem(v SnykvulndbBuildPackageEcosystem) error {
	v.Type = "build"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnykvulndbBuildPackageEcosystem performs a merge with any union data inside the SnykvulndbPackageEcosystem, using the provided SnykvulndbBuildPackageEcosystem
func (t *SnykvulndbPackageEcosystem) MergeSnykvulndbBuildPackageEcosystem(v SnykvulndbBuildPackageEcosystem) error {
	v.Type = "build"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnykvulndbOsPackageEcosystem returns the union data inside the SnykvulndbPackageEcosystem as a SnykvulndbOsPackageEcosystem
func (t SnykvulndbPackageEcosystem) AsSnykvulndbOsPackageEcosystem() (SnykvulndbOsPackageEcosystem, error) {
	var body SnykvulndbOsPackageEcosystem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnykvulndbOsPackageEcosystem overwrites any union data inside the SnykvulndbPackageEcosystem as the provided SnykvulndbOsPackageEcosystem
func (t *SnykvulndbPackageEcosystem) FromSnykvulndbOsPackageEcosystem(v SnykvulndbOsPackageEcosystem) error {
	v.Type = "os"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnykvulndbOsPackageEcosystem performs a merge with any union data inside the SnykvulndbPackageEcosystem, using the provided SnykvulndbOsPackageEcosystem
func (t *SnykvulndbPackageEcosystem) MergeSnykvulndbOsPackageEcosystem(v SnykvulndbOsPackageEcosystem) error {
	v.Type = "os"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSnykvulndbOtherPackageEcosystem returns the union data inside the SnykvulndbPackageEcosystem as a SnykvulndbOtherPackageEcosystem
func (t SnykvulndbPackageEcosystem) AsSnykvulndbOtherPackageEcosystem() (SnykvulndbOtherPackageEcosystem, error) {
	var body SnykvulndbOtherPackageEcosystem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSnykvulndbOtherPackageEcosystem overwrites any union data inside the SnykvulndbPackageEcosystem as the provided SnykvulndbOtherPackageEcosystem
func (t *SnykvulndbPackageEcosystem) FromSnykvulndbOtherPackageEcosystem(v SnykvulndbOtherPackageEcosystem) error {
	v.Type = "other"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSnykvulndbOtherPackageEcosystem performs a merge with any union data inside the SnykvulndbPackageEcosystem, using the provided SnykvulndbOtherPackageEcosystem
func (t *SnykvulndbPackageEcosystem) MergeSnykvulndbOtherPackageEcosystem(v SnykvulndbOtherPackageEcosystem) error {
	v.Type = "other"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SnykvulndbPackageEcosystem) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SnykvulndbPackageEcosystem) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "build":
		return t.AsSnykvulndbBuildPackageEcosystem()
	case "os":
		return t.AsSnykvulndbOsPackageEcosystem()
	case "other":
		return t.AsSnykvulndbOtherPackageEcosystem()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SnykvulndbPackageEcosystem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SnykvulndbPackageEcosystem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAPIVersions request
	ListAPIVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAPIVersion request
	GetAPIVersion(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, orgId OrgIdParam, jobId JobIdParam, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTestWithBody request with any body
	CreateTestWithBody(ctx context.Context, orgId OrgIdParam, params *CreateTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTestWithApplicationVndAPIPlusJSONBody(ctx context.Context, orgId OrgIdParam, params *CreateTestParams, body CreateTestApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTest request
	GetTest(ctx context.Context, orgId OrgIdParam, testId TestIdParam, params *GetTestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFindings request
	ListFindings(ctx context.Context, orgId OrgIdParam, testId TestIdParam, params *ListFindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAPIVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAPIVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAPIVersion(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIVersionRequest(c.Server, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, orgId OrgIdParam, jobId JobIdParam, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, orgId, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTestWithBody(ctx context.Context, orgId OrgIdParam, params *CreateTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTestRequestWithBody(c.Server, orgId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTestWithApplicationVndAPIPlusJSONBody(ctx context.Context, orgId OrgIdParam, params *CreateTestParams, body CreateTestApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTestRequestWithApplicationVndAPIPlusJSONBody(c.Server, orgId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTest(ctx context.Context, orgId OrgIdParam, testId TestIdParam, params *GetTestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTestRequest(c.Server, orgId, testId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFindings(ctx context.Context, orgId OrgIdParam, testId TestIdParam, params *ListFindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFindingsRequest(c.Server, orgId, testId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAPIVersionsRequest generates requests for ListAPIVersions
func NewListAPIVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAPIVersionRequest generates requests for GetAPIVersion
func NewGetAPIVersionRequest(server string, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, orgId OrgIdParam, jobId JobIdParam, params *GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/test_jobs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.SnykRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "snyk-request-id", runtime.ParamLocationHeader, *params.SnykRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("snyk-request-id", headerParam0)
		}

		if params.SnykInteractionId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "snyk-interaction-id", runtime.ParamLocationHeader, *params.SnykInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("snyk-interaction-id", headerParam1)
		}

	}

	return req, nil
}

// NewCreateTestRequestWithApplicationVndAPIPlusJSONBody calls the generic CreateTest builder with application/vnd.api+json body
func NewCreateTestRequestWithApplicationVndAPIPlusJSONBody(server string, orgId OrgIdParam, params *CreateTestParams, body CreateTestApplicationVndAPIPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTestRequestWithBody(server, orgId, params, "application/vnd.api+json", bodyReader)
}

// NewCreateTestRequestWithBody generates requests for CreateTest with any type of body
func NewCreateTestRequestWithBody(server string, orgId OrgIdParam, params *CreateTestParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/tests", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.SnykRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "snyk-request-id", runtime.ParamLocationHeader, *params.SnykRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("snyk-request-id", headerParam0)
		}

		if params.SnykInteractionId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "snyk-interaction-id", runtime.ParamLocationHeader, *params.SnykInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("snyk-interaction-id", headerParam1)
		}

	}

	return req, nil
}

// NewGetTestRequest generates requests for GetTest
func NewGetTestRequest(server string, orgId OrgIdParam, testId TestIdParam, params *GetTestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "test_id", runtime.ParamLocationPath, testId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/tests/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.SnykRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "snyk-request-id", runtime.ParamLocationHeader, *params.SnykRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("snyk-request-id", headerParam0)
		}

		if params.SnykInteractionId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "snyk-interaction-id", runtime.ParamLocationHeader, *params.SnykInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("snyk-interaction-id", headerParam1)
		}

	}

	return req, nil
}

// NewListFindingsRequest generates requests for ListFindings
func NewListFindingsRequest(server string, orgId OrgIdParam, testId TestIdParam, params *ListFindingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "test_id", runtime.ParamLocationPath, testId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/tests/%s/findings", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.SnykRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "snyk-request-id", runtime.ParamLocationHeader, *params.SnykRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("snyk-request-id", headerParam0)
		}

		if params.SnykInteractionId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "snyk-interaction-id", runtime.ParamLocationHeader, *params.SnykInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("snyk-interaction-id", headerParam1)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAPIVersionsWithResponse request
	ListAPIVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAPIVersionsResponse, error)

	// GetAPIVersionWithResponse request
	GetAPIVersionWithResponse(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*GetAPIVersionResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, orgId OrgIdParam, jobId JobIdParam, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// CreateTestWithBodyWithResponse request with any body
	CreateTestWithBodyWithResponse(ctx context.Context, orgId OrgIdParam, params *CreateTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTestResponse, error)

	CreateTestWithApplicationVndAPIPlusJSONBodyWithResponse(ctx context.Context, orgId OrgIdParam, params *CreateTestParams, body CreateTestApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTestResponse, error)

	// GetTestWithResponse request
	GetTestWithResponse(ctx context.Context, orgId OrgIdParam, testId TestIdParam, params *GetTestParams, reqEditors ...RequestEditorFn) (*GetTestResponse, error)

	// ListFindingsWithResponse request
	ListFindingsWithResponse(ctx context.Context, orgId OrgIdParam, testId TestIdParam, params *ListFindingsParams, reqEditors ...RequestEditorFn) (*ListFindingsResponse, error)
}

type ListAPIVersionsResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *[]string
	ApplicationvndApiJSON400 *N400
	ApplicationvndApiJSON401 *N401
	ApplicationvndApiJSON404 *N404
	ApplicationvndApiJSON500 *N500
}

// Status returns HTTPResponse.Status
func (r ListAPIVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAPIVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAPIVersionResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	JSON200                  *map[string]interface{}
	ApplicationvndApiJSON400 *N400
	ApplicationvndApiJSON401 *N401
	ApplicationvndApiJSON404 *N404
	ApplicationvndApiJSON500 *N500
}

// Status returns HTTPResponse.Status
func (r GetAPIVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *struct {
		// Data JobData represents a Job resource object.
		Data    JobData                `json:"data"`
		Jsonapi IoSnykApiCommonJsonApi `json:"jsonapi"`
		Links   GetJob_200_Links       `json:"links"`

		// Meta Free-form object that may contain non-standard information.
		Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
	}
	ApplicationvndApiJSON303 *struct {
		// Data JobData represents a Job resource object.
		Data    JobData                `json:"data"`
		Jsonapi IoSnykApiCommonJsonApi `json:"jsonapi"`
		Links   GetJob_303_Links       `json:"links"`

		// Meta Free-form object that may contain non-standard information.
		Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
	}
	ApplicationvndApiJSON400 *IoSnykApiCommonErrorDocument
}
type GetJob_200_Links struct {
	Related              *IoSnykApiCommonLinkProperty           `json:"related,omitempty"`
	Self                 *IoSnykApiCommonLinkProperty           `json:"self,omitempty"`
	AdditionalProperties map[string]IoSnykApiCommonLinkProperty `json:"-"`
}
type GetJob_303_Links struct {
	Related              *IoSnykApiCommonLinkProperty           `json:"related,omitempty"`
	Self                 *IoSnykApiCommonLinkProperty           `json:"self,omitempty"`
	AdditionalProperties map[string]IoSnykApiCommonLinkProperty `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTestResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON202 *struct {
		Data struct {
			// Attributes JobAttributes represents the attributes of a Job resource
			Attributes JobAttributes         `json:"attributes"`
			Id         openapi_types.UUID    `json:"id"`
			Type       CreateTest202DataType `json:"type"`
		} `json:"data"`
		Jsonapi IoSnykApiCommonJsonApi `json:"jsonapi"`
		Links   CreateTest_202_Links   `json:"links"`

		// Meta Free-form object that may contain non-standard information.
		Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
	}
	ApplicationvndApiJSON400 *IoSnykApiCommonErrorDocument
}
type CreateTest202DataType string
type CreateTest_202_Links struct {
	Related              *IoSnykApiCommonLinkProperty           `json:"related,omitempty"`
	Self                 *IoSnykApiCommonLinkProperty           `json:"self,omitempty"`
	AdditionalProperties map[string]IoSnykApiCommonLinkProperty `json:"-"`
}

// Status returns HTTPResponse.Status
func (r CreateTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTestResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *struct {
		// Data TestData represents a Test resource object.
		Data    TestData               `json:"data"`
		Jsonapi IoSnykApiCommonJsonApi `json:"jsonapi"`
		Links   GetTest_200_Links      `json:"links"`

		// Meta Free-form object that may contain non-standard information.
		Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
	}
	ApplicationvndApiJSON400 *IoSnykApiCommonErrorDocument
}
type GetTest_200_Links struct {
	Related              *IoSnykApiCommonLinkProperty           `json:"related,omitempty"`
	Self                 *IoSnykApiCommonLinkProperty           `json:"self,omitempty"`
	AdditionalProperties map[string]IoSnykApiCommonLinkProperty `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFindingsResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *struct {
		Data    []FindingData                 `json:"data"`
		Jsonapi IoSnykApiCommonJsonApi        `json:"jsonapi"`
		Links   IoSnykApiCommonPaginatedLinks `json:"links"`

		// Meta Free-form object that may contain non-standard information.
		Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
	}
	ApplicationvndApiJSON400 *IoSnykApiCommonErrorDocument
}

// Status returns HTTPResponse.Status
func (r ListFindingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFindingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAPIVersionsWithResponse request returning *ListAPIVersionsResponse
func (c *ClientWithResponses) ListAPIVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAPIVersionsResponse, error) {
	rsp, err := c.ListAPIVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAPIVersionsResponse(rsp)
}

// GetAPIVersionWithResponse request returning *GetAPIVersionResponse
func (c *ClientWithResponses) GetAPIVersionWithResponse(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*GetAPIVersionResponse, error) {
	rsp, err := c.GetAPIVersion(ctx, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIVersionResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, orgId OrgIdParam, jobId JobIdParam, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, orgId, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// CreateTestWithBodyWithResponse request with arbitrary body returning *CreateTestResponse
func (c *ClientWithResponses) CreateTestWithBodyWithResponse(ctx context.Context, orgId OrgIdParam, params *CreateTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTestResponse, error) {
	rsp, err := c.CreateTestWithBody(ctx, orgId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTestResponse(rsp)
}

func (c *ClientWithResponses) CreateTestWithApplicationVndAPIPlusJSONBodyWithResponse(ctx context.Context, orgId OrgIdParam, params *CreateTestParams, body CreateTestApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTestResponse, error) {
	rsp, err := c.CreateTestWithApplicationVndAPIPlusJSONBody(ctx, orgId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTestResponse(rsp)
}

// GetTestWithResponse request returning *GetTestResponse
func (c *ClientWithResponses) GetTestWithResponse(ctx context.Context, orgId OrgIdParam, testId TestIdParam, params *GetTestParams, reqEditors ...RequestEditorFn) (*GetTestResponse, error) {
	rsp, err := c.GetTest(ctx, orgId, testId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTestResponse(rsp)
}

// ListFindingsWithResponse request returning *ListFindingsResponse
func (c *ClientWithResponses) ListFindingsWithResponse(ctx context.Context, orgId OrgIdParam, testId TestIdParam, params *ListFindingsParams, reqEditors ...RequestEditorFn) (*ListFindingsResponse, error) {
	rsp, err := c.ListFindings(ctx, orgId, testId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFindingsResponse(rsp)
}

// ParseListAPIVersionsResponse parses an HTTP response from a ListAPIVersionsWithResponse call
func ParseListAPIVersionsResponse(rsp *http.Response) (*ListAPIVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAPIVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetAPIVersionResponse parses an HTTP response from a GetAPIVersionWithResponse call
func ParseGetAPIVersionResponse(rsp *http.Response) (*GetAPIVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data JobData represents a Job resource object.
			Data    JobData                `json:"data"`
			Jsonapi IoSnykApiCommonJsonApi `json:"jsonapi"`
			Links   GetJob_200_Links       `json:"links"`

			// Meta Free-form object that may contain non-standard information.
			Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 303:
		var dest struct {
			// Data JobData represents a Job resource object.
			Data    JobData                `json:"data"`
			Jsonapi IoSnykApiCommonJsonApi `json:"jsonapi"`
			Links   GetJob_303_Links       `json:"links"`

			// Meta Free-form object that may contain non-standard information.
			Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON303 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest IoSnykApiCommonErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	}

	return response, nil
}

// ParseCreateTestResponse parses an HTTP response from a CreateTestWithResponse call
func ParseCreateTestResponse(rsp *http.Response) (*CreateTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Data struct {
				// Attributes JobAttributes represents the attributes of a Job resource
				Attributes JobAttributes         `json:"attributes"`
				Id         openapi_types.UUID    `json:"id"`
				Type       CreateTest202DataType `json:"type"`
			} `json:"data"`
			Jsonapi IoSnykApiCommonJsonApi `json:"jsonapi"`
			Links   CreateTest_202_Links   `json:"links"`

			// Meta Free-form object that may contain non-standard information.
			Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest IoSnykApiCommonErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	}

	return response, nil
}

// ParseGetTestResponse parses an HTTP response from a GetTestWithResponse call
func ParseGetTestResponse(rsp *http.Response) (*GetTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data TestData represents a Test resource object.
			Data    TestData               `json:"data"`
			Jsonapi IoSnykApiCommonJsonApi `json:"jsonapi"`
			Links   GetTest_200_Links      `json:"links"`

			// Meta Free-form object that may contain non-standard information.
			Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest IoSnykApiCommonErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	}

	return response, nil
}

// ParseListFindingsResponse parses an HTTP response from a ListFindingsWithResponse call
func ParseListFindingsResponse(rsp *http.Response) (*ListFindingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFindingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data    []FindingData                 `json:"data"`
			Jsonapi IoSnykApiCommonJsonApi        `json:"jsonapi"`
			Links   IoSnykApiCommonPaginatedLinks `json:"links"`

			// Meta Free-form object that may contain non-standard information.
			Meta *IoSnykApiCommonMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest IoSnykApiCommonErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	}

	return response, nil
}
